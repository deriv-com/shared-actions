name: AI Code Analysis Report

on:
  # Make this a reusable workflow
  workflow_call:
    inputs:
      target_ref:
        description: 'Target ref to analyze (default: PR head)'
        required: false
        type: string
        default: ''
      base_ref:
        description: 'Base ref for comparison (default: PR base)'
        required: false
        type: string
        default: ''
      github_token:
        description: 'GitHub token for API access'
        required: false
        type: string
        default: ''
    secrets:
      PERSONAL_ACCESS_TOKEN:
        description: 'Personal access token for user verification'
        required: true

jobs:
  analyze-ai-code:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      pull-requests: write
      issues: write
    env:
      PR_USER_LOGIN: ${{ github.event.pull_request.user.login }}
      PR_HEAD_SHA: ${{ inputs.target_ref || github.event.pull_request.head.sha }}
      PR_BASE_REF: ${{ inputs.base_ref || github.event.pull_request.base.ref }}
      GITHUB_TOKEN_INPUT: ${{ inputs.github_token || github.token }}
      PAT_TOKEN: ${{ secrets.PERSONAL_ACCESS_TOKEN }}
      GITHUB_REPOSITORY: ${{ github.repository }}
      GITHUB_EVENT_NAME: ${{ github.event_name }}
      PR_MERGED_AT: ${{ github.event.pull_request.merged_at }}
      PR_HEAD_REF: ${{ github.event.pull_request.head.ref }}
      PR_USER_TYPE: ${{ github.event.pull_request.user.type }}
      ISSUE_NUMBER: ${{ github.event.number }}
      REPO_OWNER: ${{ github.repository_owner }}
      REPO_NAME: ${{ github.event.repository.name }}
    
    steps:
      - name: Verify user
        uses: 'deriv-com/shared-actions/.github/actions/verify_user_in_organization@v3'
        with:
          username: ${{ env.PR_USER_LOGIN }}
          # Security: Use dedicated PAT for user verification (should have minimal org:read scope)
          token: ${{ env.PAT_TOKEN }}
          
      - name: Checkout code
        uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2
        with:
          # For pull_request_target, checkout the PR head to analyze the actual changes
          ref: ${{ env.PR_HEAD_SHA }}
          fetch-depth: 0

      - name: Setup Node.js
        uses: actions/setup-node@1e60f620b9541d16bece96c5465dc8ee9832be0b # v4.0.4
        with:
          node-version: '18'

      - name: Get changed files and their diffs
        id: changed-files
        run: |
          # Security: Use validated environment variables instead of direct GitHub context
          echo "🔍 Getting changed files for PR..."
          git diff --name-only "origin/$PR_BASE_REF...HEAD" > changed_files.txt
          echo "Changed files:"
          cat changed_files.txt

      - name: Analyze AI code in PR changes only
        id: analyze
        run: |
          cat > analyze_script.js << 'EOF'
          const fs = require('fs');
          const path = require('path');
          const { execSync } = require('child_process');
          
          // Universal AI Block Detection - detects AI blocks regardless of comment syntax
          const AI_BLOCK_REGEXES = [
            {
              name: 'universal',
              regex: /\[AI\]([\s\S]*?)\[\/AI\]/g,
              description: 'Universal AI block detection regardless of comment style'
            }
          ];
          
          function getChangedContent(filePath) {
            try {
              // Security: Use environment variable instead of GitHub context to prevent injection
              const baseRef = process.env.PR_BASE_REF;
              if (!baseRef) {
                throw new Error('PR_BASE_REF environment variable not set');
              }
              
              // Security: Validate file path to prevent path traversal
              if (filePath.includes('..') || filePath.startsWith('/')) {
                throw new Error(`Invalid file path: ${filePath}`);
              }
              
              // Get the diff for this specific file, showing only added lines
              // Note: Using path.normalize() would require additional import, 
              // but git itself provides good protection against path traversal
              const diffCommand = `git diff origin/${baseRef}...HEAD -- "${filePath}"`;
              const diffOutput = execSync(diffCommand, { encoding: 'utf8' });
              
              // Extract only the added lines (lines starting with +, but not +++)
              const addedLines = diffOutput
                .split('\n')
                .filter(line => line.startsWith('+') && !line.startsWith('+++'))
                .map(line => line.substring(1)) // Remove the + prefix
                .join('\n');
              
              return addedLines;
            } catch (error) {
              console.error(`Error getting diff for ${filePath}:`, error.message);
              return '';
            }
          }
          
          function analyzeFile(filePath) {
            try {
              if (!fs.existsSync(filePath)) return null;
          
              // Only analyze the added content in the PR, not the entire file
              const addedContent = getChangedContent(filePath);
              
              if (!addedContent || addedContent.trim() === '') {
                return {
                  name: filePath,
                  totalCharacters: 0,
                  aiCharacters: 0,
                  percentage: 0,
                  note: 'No added content in this PR'
                };
              }
              
              let aiCharacters = 0;
              const totalCharacters = addedContent.length;
              
              for (const regexDef of AI_BLOCK_REGEXES) {
                const regex = new RegExp(regexDef.regex.source, regexDef.regex.flags);
                let match;
                
                while ((match = regex.exec(addedContent)) !== null) {
                  const codeContent = match[1] || '';
                  aiCharacters += codeContent.length;
                  
                  if (!regexDef.regex.global) break;
                }
              }
              
              return {
                name: filePath,
                totalCharacters,
                aiCharacters,
                percentage: totalCharacters > 0 ? Math.round((aiCharacters / totalCharacters) * 100) : 0,
                addedContent: addedContent.substring(0, 200) + (addedContent.length > 200 ? '...' : '') // Preview
              };
              
            } catch (error) {
              console.error('Error analyzing file ' + filePath + ':', error.message);
              return null;
            }
          }
          
          // Read changed files
          const changedFilesContent = fs.readFileSync('changed_files.txt', 'utf8');
          const changedFiles = changedFilesContent
            .split('\n')
            .map(line => line.trim())
            .filter(line => line.length > 0)
            .filter(file => {
              const ext = path.extname(file).toLowerCase();
              const codeExtensions = [
                '.js', '.ts', '.jsx', '.tsx', '.java', '.c', '.cpp', '.go', '.cs', 
                '.swift', '.scala', '.dart', '.kt', '.rs', '.py', '.sh', '.rb', 
                '.pl', '.yml', '.yaml', '.toml', '.env', '.ini', '.cfg', '.conf', 
                '.R', '.groovy', '.html', '.xml', '.md', '.markdown', '.vue', 
                '.svelte', '.xhtml', '.svg', '.css', '.scss', '.sass', '.less'
              ];
              return codeExtensions.includes(ext);
            });

          console.log('Analyzing ' + changedFiles.length + ' code files...');

          const results = {
            files: [],
            summary: {
              totalCharacters: 0,
              aiCharacters: 0,
              percentage: 0
            }
          };

          for (const file of changedFiles) {
            const analysis = analyzeFile(file);
            if (analysis) {
              results.files.push(analysis);
              results.summary.totalCharacters += analysis.totalCharacters;
              results.summary.aiCharacters += analysis.aiCharacters;
              
              console.log(file + ': ' + analysis.aiCharacters + '/' + analysis.totalCharacters + ' chars (' + analysis.percentage + '%) AI');
            }
          }

          if (results.summary.totalCharacters > 0) {
            results.summary.percentage = Math.round(
              (results.summary.aiCharacters / results.summary.totalCharacters) * 100
            );
          }

          fs.writeFileSync('ai_analysis_results.json', JSON.stringify(results, null, 2));

          console.log('\n=== SUMMARY ===');
          console.log('Total files analyzed: ' + results.files.length);
          console.log('Total characters: ' + results.summary.totalCharacters);
          console.log('AI characters: ' + results.summary.aiCharacters);
          console.log('Overall AI percentage: ' + results.summary.percentage + '%');
          EOF
          
          node analyze_script.js

      - name: Post AI Code Analysis Report
        uses: actions/github-script@60a0d83039c74a4aee543508d2ffcb1c3799cdea # v7.0.1
        with:
          # Security: Uses GITHUB_TOKEN (read-only for this operation) with minimal required permissions
          # Permissions needed: issues:write, pull-requests:write (defined at job level)
          github-token: ${{ env.GITHUB_TOKEN_INPUT }}
          script: |
            const fs = require('fs');
            
         
            const repository = process.env.GITHUB_REPOSITORY;
            const eventName = process.env.GITHUB_EVENT_NAME;
            const prMergedAt = process.env.PR_MERGED_AT;
            const prHeadRef = process.env.PR_HEAD_REF;
            const prUserLogin = process.env.PR_USER_LOGIN;
            const issueNumber = process.env.ISSUE_NUMBER;
            
            // Read analysis results
            const results = JSON.parse(fs.readFileSync('ai_analysis_results.json', 'utf8'));
            
            // Helper functions for visual elements
            function createProgressBar(percentage, width = 15) {
              const filled = Math.round((percentage / 100) * width);
              const empty = width - filled;
              
              // Use emoji blocks for consistent sizing
              let filledEmoji = '🟥'; // Red for low usage
              if (percentage >= 80) filledEmoji = '🟩';      // Green (80-100%)
              else if (percentage >= 50) filledEmoji = '🟨'; // Yellow (50-79%)  
              else if (percentage >= 21) filledEmoji = '🟧'; // Orange (21-49%)
              
              // Create bar with consistent emoji blocks
              const filledBar = filledEmoji.repeat(filled);
              const emptyBar = '⬜'.repeat(empty);
              const bar = filledBar + emptyBar;
              
              // Pad percentage to ensure consistent width
              const paddedPercentage = percentage.toString().padStart(3, ' ');
              
              return `${bar} ${paddedPercentage}%`;
            }
            

            function getAILevelInfo(percentage) {
              if (percentage === 0) {
                return {
                  emoji: '📝',
                  level: 'Manual Coding',
                  description: 'This PR contains traditional hand-written code.',
                  color: '#6c757d'
                };
              } else if (percentage <= 20) {
                return {
                  emoji: '🌱',
                  level: 'AI-Assisted Development',
                  description: `${percentage}% AI-generated code shows some AI assistance in development.`,
                  color: '#28a745'
                };
              } else if (percentage <= 50) {
                return {
                  emoji: '🔧',
                  level: 'Moderate AI Usage', 
                  description: `${percentage}% AI-generated code demonstrates moderate AI adoption.`,
                  color: '#ffc107'
                };
              } else if (percentage <= 79) {
                return {
                  emoji: '🚀',
                  level: 'High AI Productivity',
                  description: `Great! ${percentage}% AI-generated code shows high AI productivity.`,
                  color: '#17a2b8'
                };
              } else {
                return {
                  emoji: '⚡',
                  level: 'Strong AI Application',
                  description: `Outstanding! ${percentage}% AI-generated code demonstrates strong AI application.`,
                  color: '#007bff'
                };
              }
            }
            
            // Create the beautiful comment
            let comment = '';
            
            if (results.files.length === 0) {
              comment = `## 🤖 AI Code Analysis
            
            <div align="center">
            
            ### 📄 No Changes Found
            
            No AI-generated code detected in the newly added lines of this PR.
            
            </div>
            
            ---
            <sub>🚀 Analysis powered by **ShiftAI** • Analyzes only PR changes, not entire files</sub>`;
            } else {
              const aiInfo = getAILevelInfo(results.summary.percentage);
              
              comment = `## 🤖 AI Code Analysis Results
            
            <div align="center">
            
            ### ${aiInfo.emoji} ${aiInfo.level}
            
            ${createProgressBar(results.summary.percentage, 25)}
            
            **${results.summary.aiCharacters.toLocaleString()}** of **${results.summary.totalCharacters.toLocaleString()}** characters (${results.summary.percentage}%) in **newly added lines** are AI-generated
            
            </div>
            
            ---
            
            ### 📊 Analysis Summary
            
            | Metric | Value |
            |--------|-------|
            | 📁 **Files Changed** | ${results.files.length} |
            | ➕ **New Lines Added** | ${results.summary.totalCharacters.toLocaleString()} chars |
            | 🤖 **AI Characters** | ${results.summary.aiCharacters.toLocaleString()} |
            | 📈 **AI Percentage** | **${results.summary.percentage}%** |
            
            ---
            
            ### 📋 Per-File Breakdown (New Lines Only)
            
            | File | Lines Added | AI Content | Percentage |
            |------|-------------|------------|------------|`;
            
              // Add file details
              results.files
                .sort((a, b) => b.percentage - a.percentage)
                .forEach(file => {
                  const fileName = file.name.length > 40 ? '...' + file.name.slice(-37) : file.name;
                  const progressBar = createProgressBar(file.percentage, 15);
                  
                  comment += `\n| \`${fileName}\` | ${file.totalCharacters} chars | ${file.aiCharacters} chars | ${progressBar} |`;
                });
              
              comment += `\n\n---\n\n`;
              comment += `<div align="center">\n\n`;
              comment += `${aiInfo.emoji} **${aiInfo.description}**\n\n`;
              comment += `</div>\n\n`;
              
              // Add structured data for dashboard
              comment += `<details>\n<summary>📊 Raw Data (for dashboard)</summary>\n\n\`\`\`json\n`;
              comment += JSON.stringify({
                timestamp: new Date().toISOString(),
                repository: repository,
                pullRequest: issueNumber,
                branch: prHeadRef,
                author: prUserLogin,
                ...results
              }, null, 2);
              comment += `\n\`\`\`\n\n</details>\n\n`;
              
              comment += `---\n<sub>🚀 Analysis powered by **ShiftAI** • Analyzes only PR changes, not entire files</sub>`;
            }
            
            // Check for existing AI analysis comment
            const comments = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number
            });
            
            // Find existing AI analysis comment (look for the unique identifier)
            const existingComment = comments.data.find(comment => 
              comment.body.includes('🤖 AI Code Analysis') && 
              comment.user.type === 'Bot'
            );
            
            if (existingComment) {
              // Update existing comment
              await github.rest.issues.updateComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                comment_id: existingComment.id,
                body: comment
              });
              console.log('✅ Updated existing AI analysis comment #' + existingComment.id);
            } else {
              // Create new comment
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
                body: comment
              });
              console.log('✅ Created new AI analysis comment');
            } 