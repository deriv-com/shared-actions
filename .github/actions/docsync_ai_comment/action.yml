name: "DocSync AI - Update from Comment"
description: "Update documentation in existing DocSync PR based on user comment suggestions"

inputs:
  github_token:
    description: "GitHub token for repository operations and PR creation"
    required: true
  anthropic_api_key:
    description: "Anthropic API key for Claude AI"
    required: true
  repository:
    description: "Repository name (owner/repo)"
    required: true
  pr_number:
    description: "PR number where comment was made"
    required: true
  comment_body:
    description: "Comment body with user suggestion (must start with 'docsync:')"
    required: true
  base_branch:
    description: "Base branch for documentation PR (e.g., master or main)"
    required: false
    default: "master"

outputs:
  updated:
    description: "Whether documentation was updated"
    value: "${{ steps.commit-changes.outputs.updated }}"
  suggestion_valid:
    description: "Whether the comment had valid docsync prefix"
    value: "${{ steps.validate.outputs.valid }}"
  is_docsync_pr:
    description: "Whether the PR is a DocSync PR"
    value: "${{ steps.verify-pr.outputs.is_docsync_pr }}"

runs:
  using: composite
  steps:
    - name: âœ… Validate Comment Prefix
      id: validate
      shell: bash
      env:
        COMMENT_BODY: ${{ inputs.comment_body }}
      run: |
        set -e

        echo "## âœ… Validating Comment" >> $GITHUB_STEP_SUMMARY

        # Sanitize comment body (remove null bytes, limit size)
        COMMENT_BODY_CLEAN=$(echo "$COMMENT_BODY" | tr -d '\000' | iconv -c -t UTF-8//IGNORE | head -c 10000)

        # Validate for suspicious patterns
        if echo "$COMMENT_BODY_CLEAN" | grep -qE '\$\(|\`|;[[:space:]]*curl|;[[:space:]]*wget|eval|exec'; then
          echo "âš ï¸ Warning: Suspicious pattern detected in comment" >> $GITHUB_STEP_SUMMARY
          # Continue but log warning
        fi

        # Check if comment starts with "docsync:" (case-insensitive)
        if echo "$COMMENT_BODY_CLEAN" | grep -qiE "^docsync:[[:space:]]"; then
          echo "valid=true" >> $GITHUB_OUTPUT
          echo "âœ… Valid docsync comment detected" >> $GITHUB_STEP_SUMMARY

          # Extract suggestion safely (everything after "docsync:")
          SUGGESTION=$(echo "$COMMENT_BODY_CLEAN" | sed -E 's/^[Dd][Oo][Cc][Ss][Yy][Nn][Cc]:[[:space:]]*//')

          # Validate suggestion is not empty
          if [ -z "$SUGGESTION" ]; then
            echo "valid=false" >> $GITHUB_OUTPUT
            echo "âŒ Comment suggestion is empty" >> $GITHUB_STEP_SUMMARY
            exit 0
          fi

          # Limit suggestion size for output
          SUGGESTION_DISPLAY=$(echo "$SUGGESTION" | head -c 500)

          echo "suggestion<<EOF" >> $GITHUB_OUTPUT
          echo "$SUGGESTION" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

          echo "### User Suggestion:" >> $GITHUB_STEP_SUMMARY
          echo '```' >> $GITHUB_STEP_SUMMARY
          echo "$SUGGESTION_DISPLAY" >> $GITHUB_STEP_SUMMARY
          if [ ${#SUGGESTION} -gt 500 ]; then
            echo "... (truncated for display)" >> $GITHUB_STEP_SUMMARY
          fi
          echo '```' >> $GITHUB_STEP_SUMMARY
        else
          echo "valid=false" >> $GITHUB_OUTPUT
          echo "âŒ Comment does not start with 'docsync:' - skipping" >> $GITHUB_STEP_SUMMARY
          exit 0
        fi

    - name: ðŸ” Verify DocSync PR
      id: verify-pr
      if: steps.validate.outputs.valid == 'true'
      shell: bash
      env:
        GH_TOKEN: ${{ inputs.github_token }}
        PR_NUMBER: ${{ inputs.pr_number }}
        REPO_NAME: ${{ inputs.repository }}
      run: |
        set -e

        echo "## ðŸ” Verifying DocSync PR" >> $GITHUB_STEP_SUMMARY

        # Validate PR number
        if ! [[ "$PR_NUMBER" =~ ^[0-9]+$ ]]; then
          echo "âŒ Invalid PR number: $PR_NUMBER" >> $GITHUB_STEP_SUMMARY
          exit 1
        fi

        if [ "$PR_NUMBER" -lt 1 ] || [ "$PR_NUMBER" -gt 999999 ]; then
          echo "âŒ PR number out of valid range: $PR_NUMBER" >> $GITHUB_STEP_SUMMARY
          exit 1
        fi

        # Validate repository format
        if ! [[ "$REPO_NAME" =~ ^[a-zA-Z0-9_-]+/[a-zA-Z0-9_.-]+$ ]]; then
          echo "âŒ Invalid repository format: $REPO_NAME" >> $GITHUB_STEP_SUMMARY
          exit 1
        fi

        # Get PR details including labels and title
        PR_DATA=$(gh api \
          -H "Accept: application/vnd.github+json" \
          "/repos/$REPO_NAME/pulls/$PR_NUMBER")

        # Validate response is valid JSON
        if ! echo "$PR_DATA" | jq empty 2>/dev/null; then
          echo "âŒ Invalid response from GitHub API" >> $GITHUB_STEP_SUMMARY
          exit 1
        fi

        # Extract labels
        PR_LABELS=$(echo "$PR_DATA" | jq -r '.labels[].name' 2>&1 || echo "")

        # Extract PR title and sanitize
        PR_TITLE=$(echo "$PR_DATA" | jq -r '.title' 2>&1 || echo "")
        PR_TITLE=$(echo "$PR_TITLE" | tr -d '\000-\037' | head -c 200)

        # Extract PR branch and validate
        PR_BRANCH=$(echo "$PR_DATA" | jq -r '.head.ref' 2>&1 || echo "")

        # Validate branch name format
        if ! [[ "$PR_BRANCH" =~ ^[a-zA-Z0-9/_.-]+$ ]]; then
          echo "âŒ Invalid branch name format" >> $GITHUB_STEP_SUMMARY
          exit 1
        fi

        # Sanitize labels for display
        PR_LABELS_DISPLAY=$(echo "$PR_LABELS" | head -n 10)

        echo "### PR Information:" >> $GITHUB_STEP_SUMMARY
        echo "- **Title**: ${PR_TITLE:0:100}" >> $GITHUB_STEP_SUMMARY
        echo "- **Branch**: $PR_BRANCH" >> $GITHUB_STEP_SUMMARY
        echo "- **Labels**: ${PR_LABELS_DISPLAY:-'(none)'}" >> $GITHUB_STEP_SUMMARY

        # Check if PR has docsync-ai or automated label, OR if title contains "DocSync"
        IS_DOCSYNC_PR=false

        if echo "$PR_LABELS" | grep -qE "(docsync-ai|automated)"; then
          IS_DOCSYNC_PR=true
          echo "âœ… PR has DocSync label" >> $GITHUB_STEP_SUMMARY
        elif echo "$PR_TITLE" | grep -qi "docsync"; then
          IS_DOCSYNC_PR=true
          echo "âœ… PR title contains 'DocSync'" >> $GITHUB_STEP_SUMMARY
        fi

        if [ "$IS_DOCSYNC_PR" = true ]; then
          echo "is_docsync_pr=true" >> $GITHUB_OUTPUT
          echo "pr_branch=$PR_BRANCH" >> $GITHUB_OUTPUT
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "âœ… **Verified as DocSync PR**" >> $GITHUB_STEP_SUMMARY
        else
          echo "is_docsync_pr=false" >> $GITHUB_OUTPUT
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "âŒ **Not a DocSync PR**" >> $GITHUB_STEP_SUMMARY
          echo "This feature only works on DocSync PRs (with 'docsync-ai'/'automated' labels or 'DocSync' in title)" >> $GITHUB_STEP_SUMMARY
          exit 0
        fi

    - name: ðŸ“¥ Checkout PR Branch
      if: steps.verify-pr.outputs.is_docsync_pr == 'true'
      uses: actions/checkout@v4
      with:
        token: ${{ inputs.github_token }}
        ref: ${{ steps.verify-pr.outputs.pr_branch }}
        fetch-depth: 0

    - name: ðŸ¤– Run Claude Sonnet 4.5 Documentation Analysis
      id: claude-analysis
      if: steps.verify-pr.outputs.is_docsync_pr == 'true'
      shell: bash
      env:
        ANTHROPIC_API_KEY: ${{ inputs.anthropic_api_key }}
        REPO_NAME: ${{ inputs.repository }}
        PR_NUMBER: ${{ inputs.pr_number }}
        USER_SUGGESTION: ${{ steps.validate.outputs.suggestion }}
      run: |
        set -e

        echo "## ðŸ¤– Claude Sonnet 4.5 Analysis" >> $GITHUB_STEP_SUMMARY
        echo "Model: claude-sonnet-4-5-latest" >> $GITHUB_STEP_SUMMARY

        # Create secure temporary directory
        TEMP_DIR=$(mktemp -d -t docsync-comment-XXXXXXXXXX)
        trap "rm -rf '$TEMP_DIR'" EXIT

        # Sanitize user suggestion
        USER_SUGGESTION_CLEAN=$(echo "$USER_SUGGESTION" | tr -d '\000' | iconv -c -t UTF-8//IGNORE | head -c 10000)

        # Validate file paths helper function
        validate_doc_file() {
          local file=$1
          # Must be in current directory, not a symlink, and match expected names
          if [[ ! -f "$file" ]] || [[ -L "$file" ]]; then
            return 1
          fi
          local basename=$(basename "$file")
          local basename_lower=$(echo "$basename" | tr '[:upper:]' '[:lower:]')
          if [[ "$basename_lower" != "readme.md" ]] && [[ "$basename_lower" != "claude.md" ]]; then
            return 1
          fi
          # Ensure file is in repo root (no directory traversal)
          local realpath=$(realpath "$file" 2>/dev/null || echo "")
          local workdir=$(realpath . 2>/dev/null || echo "")
          if [[ ! "$realpath" == "$workdir"/* ]]; then
            return 1
          fi
          return 0
        }

        # === PHASE 1: DETECT ALL DOCUMENTATION FILES ===
        # Check for BOTH files before updating anything
        HAS_README=false
        HAS_CLAUDE=false

        # Case-insensitive check for README.md
        README_FILE=$(find . -maxdepth 1 -type f -iname "readme.md" -print -quit 2>/dev/null)
        if [ -n "$README_FILE" ]; then
          README_FILE="${README_FILE#./}"
          if validate_doc_file "$README_FILE"; then
            HAS_README=true
          else
            echo "âš ï¸ Invalid README file detected, skipping" >> $GITHUB_STEP_SUMMARY
            README_FILE=""
          fi
        fi

        # Case-insensitive check for CLAUDE.md
        CLAUDE_FILE=$(find . -maxdepth 1 -type f -iname "claude.md" -print -quit 2>/dev/null)
        if [ -n "$CLAUDE_FILE" ]; then
          CLAUDE_FILE="${CLAUDE_FILE#./}"
          if validate_doc_file "$CLAUDE_FILE"; then
            HAS_CLAUDE=true
          else
            echo "âš ï¸ Invalid CLAUDE file detected, skipping" >> $GITHUB_STEP_SUMMARY
            CLAUDE_FILE=""
          fi
        fi

        # Log detection results for both files
        echo "### ðŸ“„ Documentation File Detection:" >> $GITHUB_STEP_SUMMARY
        echo "- README.md: $([ "$HAS_README" = true ] && echo "âœ… Found ($README_FILE)" || echo 'âŒ Not found')" >> $GITHUB_STEP_SUMMARY
        echo "- CLAUDE.md: $([ "$HAS_CLAUDE" = true ] && echo "âœ… Found ($CLAUDE_FILE)" || echo 'âŒ Not found')" >> $GITHUB_STEP_SUMMARY

        if [ "$HAS_README" = false ] && [ "$HAS_CLAUDE" = false ]; then
          echo "âŒ No documentation file found (README.md or CLAUDE.md)" >> $GITHUB_STEP_SUMMARY
          echo "skip_analysis=true" >> $GITHUB_OUTPUT
          exit 0
        fi

        ANY_UPDATES=false

        # Function to call Claude API for documentation update
        update_doc_file() {
          local DOC_FILE=$1
          local DOC_FORMAT=$2
          local OTHER_FILES_NOTE=$3

          echo "Processing $DOC_FILE..." >> $GITHUB_STEP_SUMMARY

          # Validate doc file path
          if ! validate_doc_file "$DOC_FILE"; then
            echo "  âŒ Invalid doc file: $DOC_FILE" >> $GITHUB_STEP_SUMMARY
            return 1
          fi

          # Read current documentation
          DOC_CONTENT=$(cat "$DOC_FILE")

          # Extract project title/name for validation (from first heading)
          PROJECT_TITLE=$(echo "$DOC_CONTENT" | head -n 30 | grep -E "^#\s+" | head -n 1 | sed 's/^#*\s*//' | tr -d '\000-\037' | head -c 200)
          if [ -z "$PROJECT_TITLE" ]; then
            PROJECT_TITLE="Unknown Project"
          fi

          # Extract key terms from existing documentation for validation
          KEY_TERMS=$(echo "$DOC_CONTENT" | head -n 100 | grep -oE '\b[A-Z][A-Za-z0-9]{3,}\b' | sort -u | head -n 20 | tr '\n' ',' | sed 's/,$//')

          echo "  ðŸ“Œ Project: $PROJECT_TITLE" >> $GITHUB_STEP_SUMMARY

          # Validate content size
          CONTENT_SIZE=${#DOC_CONTENT}
          MAX_CONTENT_SIZE=524288  # 512KB
          if [ $CONTENT_SIZE -gt $MAX_CONTENT_SIZE ]; then
            echo "  âš ï¸ Doc file too large: $CONTENT_SIZE bytes" >> $GITHUB_STEP_SUMMARY
            return 1
          fi

          # Prepare the prompt based on file type
          if [ "$DOC_FORMAT" = "README" ]; then
            FORMAT_INSTRUCTION="This is a README.md file. Maintain standard README format with clear sections, proper markdown formatting, badges, installation instructions, usage examples, and project overview. Keep the professional, user-facing documentation style."
          else
            FORMAT_INSTRUCTION="This is a CLAUDE.md file for AI assistance. Maintain the technical, detailed format suitable for AI context with implementation details, architecture notes, and development guidelines. Keep the detailed, technical documentation style."
          fi

          # Create secure prompt file
          PROMPT_FILE="$TEMP_DIR/claude_prompt_$(openssl rand -hex 8).txt"

          # Build prompt with safe variable substitution
          cat > "$PROMPT_FILE" << 'EOF'
        You are a technical documentation expert. A user has provided a suggestion for improving the documentation in a DocSync PR.

        ## IMPORTANT: PROJECT IDENTITY
        This documentation is for: '"$PROJECT_TITLE"'
        Repository: '"$REPO_NAME"'

        **CRITICAL**: You MUST maintain the project identity. This is NOT a different project. Do NOT replace this documentation with content about any other project, library, or tool.

        ## Context
        PR #'"$PR_NUMBER"' (DocSync Documentation PR)

        ## Current Documentation Content:
        ```
        '"$DOC_CONTENT"'
        ```

        ## User Suggestion:
        ```
        '"$USER_SUGGESTION_CLEAN"'
        ```

        ## Format Requirements:
        '"$FORMAT_INSTRUCTION"'

        ## Additional Context:
        '"$OTHER_FILES_NOTE"'

        ## Your Task
        Apply the user'\''s suggestion to update the '"$DOC_FILE"' while maintaining project identity and existing content.

        ## ABSOLUTE REQUIREMENTS - VIOLATION WILL BE REJECTED:

        1. **PRESERVE PROJECT IDENTITY**:
           - The project name "'"$PROJECT_TITLE"'" MUST remain unchanged
           - Do NOT replace this with documentation for a different project
           - Maintain all existing project-specific information

        2. **ONLY ADD OR REFINE, NEVER REMOVE**:
           - Apply the user'\''s suggestion by adding or refining content
           - NEVER remove existing sections, features, or content unless explicitly requested
           - NEVER replace existing content with unrelated information
           - Keep all existing headings, sections, and structure intact

        3. **FOLLOW USER INTENT**:
           - Carefully interpret and apply the user'\''s suggestion
           - If the suggestion is about adding content, add it to the appropriate section
           - If it'\''s about improving clarity, refine the existing text
           - If it'\''s vague, make conservative, relevant improvements

        4. **VERIFY PROJECT MATCH**:
           - Ensure any additions are relevant to "'"$PROJECT_TITLE"'" in "'"$REPO_NAME"'"
           - Do NOT add information about unrelated projects or technologies
           - Maintain consistency with existing content

        5. **OUTPUT FORMAT**:
           - Output ONLY the complete updated documentation content
           - NO preambles, acknowledgments, or explanatory text
           - NO phrases like "Here'\''s the updated", "I'\''ve applied", etc.
           - Start directly with the documentation content

        6. **QUALITY STANDARDS**:
           - Ensure updates are accurate and clear
           - Maintain consistent formatting and style
           - Improve documentation quality based on the suggestion

        ## Response:
        Output the COMPLETE updated documentation with the user'\''s suggestion applied.

        Begin your response now:
        EOF

          chmod 600 "$PROMPT_FILE"
          FULL_PROMPT=$(cat "$PROMPT_FILE")

          # Call Claude API with secure header handling
          echo "  Calling Claude API for $DOC_FILE..." >> $GITHUB_STEP_SUMMARY

          # Create secure request body file
          REQUEST_FILE="$TEMP_DIR/request_$(openssl rand -hex 8).json"
          jq -n \
            --arg model "claude-sonnet-4-5-latest" \
            --argjson max_tokens 8192 \
            --arg content "$FULL_PROMPT" \
            '{
              model: $model,
              max_tokens: $max_tokens,
              messages: [{
                role: "user",
                content: $content
              }]
            }' > "$REQUEST_FILE"

          chmod 600 "$REQUEST_FILE"

          # Call API
          RESPONSE=$(curl -s https://api.anthropic.com/v1/messages \
            -H "content-type: application/json" \
            -H "x-api-key: $ANTHROPIC_API_KEY" \
            -H "anthropic-version: 2023-06-01" \
            -d @"$REQUEST_FILE")

          # Clean up request file
          rm -f "$REQUEST_FILE"

          # Validate response is valid JSON
          if ! echo "$RESPONSE" | jq empty 2>/dev/null; then
            echo "  âŒ Invalid JSON response from API" >> $GITHUB_STEP_SUMMARY
            return 1
          fi

          # Check for API errors
          if echo "$RESPONSE" | jq -e '.error' > /dev/null 2>&1; then
            ERROR_TYPE=$(echo "$RESPONSE" | jq -r '.error.type // "unknown"')
            ERROR_CODE=$(echo "$RESPONSE" | jq -r '.error.code // "unknown"')
            echo "  âŒ Claude API Error for $DOC_FILE: type=$ERROR_TYPE, code=$ERROR_CODE" >> $GITHUB_STEP_SUMMARY
            return 1
          fi

          # Validate response structure
          if ! echo "$RESPONSE" | jq -e '.content[0].text' > /dev/null 2>&1; then
            echo "  âŒ API response missing expected content field" >> $GITHUB_STEP_SUMMARY
            return 1
          fi

          # Extract the response content
          CLAUDE_OUTPUT=$(echo "$RESPONSE" | jq -r '.content[0].text')

          # Validate output size
          OUTPUT_SIZE=${#CLAUDE_OUTPUT}
          MAX_OUTPUT_SIZE=524288  # 512KB
          if [ $OUTPUT_SIZE -gt $MAX_OUTPUT_SIZE ]; then
            echo "  âŒ Claude output too large: $OUTPUT_SIZE bytes" >> $GITHUB_STEP_SUMMARY
            return 1
          fi

          # Sanitize output (remove null bytes, validate UTF-8)
          CLAUDE_OUTPUT=$(echo "$CLAUDE_OUTPUT" | tr -d '\000' | iconv -c -t UTF-8//IGNORE)

          # ===== HALLUCINATION PREVENTION VALIDATION =====
          echo "  ðŸ” Validating output for hallucination..." >> $GITHUB_STEP_SUMMARY

          # Validation 1: Check project title is preserved
          if [ "$PROJECT_TITLE" != "Unknown Project" ]; then
            PROJECT_NAME_CORE=$(echo "$PROJECT_TITLE" | cut -d: -f1 | cut -d- -f1 | xargs)
            if ! echo "$CLAUDE_OUTPUT" | head -n 50 | grep -qi "$PROJECT_NAME_CORE"; then
              echo "  âŒ VALIDATION FAILED: Project title '$PROJECT_TITLE' not found in output" >> $GITHUB_STEP_SUMMARY
              echo "  âš ï¸ Possible hallucination detected - rejecting update" >> $GITHUB_STEP_SUMMARY
              return 1
            fi
          fi

          # Validation 2: Check output length isn't drastically different (hallucination indicator)
          INPUT_LENGTH=${#DOC_CONTENT}
          OUTPUT_LENGTH=${#CLAUDE_OUTPUT}

          # Allow output to be 50%-200% of input length (prevent complete rewrites)
          MIN_LENGTH=$((INPUT_LENGTH * 50 / 100))
          MAX_LENGTH=$((INPUT_LENGTH * 200 / 100))

          if [ $OUTPUT_LENGTH -lt $MIN_LENGTH ]; then
            echo "  âŒ VALIDATION FAILED: Output too short ($OUTPUT_LENGTH vs $INPUT_LENGTH chars)" >> $GITHUB_STEP_SUMMARY
            echo "  âš ï¸ Possible content removal detected - rejecting update" >> $GITHUB_STEP_SUMMARY
            return 1
          fi

          if [ $OUTPUT_LENGTH -gt $MAX_LENGTH ]; then
            echo "  âŒ VALIDATION FAILED: Output too long ($OUTPUT_LENGTH vs $INPUT_LENGTH chars)" >> $GITHUB_STEP_SUMMARY
            echo "  âš ï¸ Possible hallucination detected - rejecting update" >> $GITHUB_STEP_SUMMARY
            return 1
          fi

          # Validation 3: Check that first heading is preserved
          ORIGINAL_HEADING=$(echo "$DOC_CONTENT" | grep -E "^#\s+" | head -n 1 | sed 's/^#*\s*//')
          NEW_HEADING=$(echo "$CLAUDE_OUTPUT" | grep -E "^#\s+" | head -n 1 | sed 's/^#*\s*//')

          if [ -n "$ORIGINAL_HEADING" ] && [ "$ORIGINAL_HEADING" != "$NEW_HEADING" ]; then
            echo "  âš ï¸ WARNING: First heading changed from '$ORIGINAL_HEADING' to '$NEW_HEADING'" >> $GITHUB_STEP_SUMMARY
            echo "  âŒ VALIDATION FAILED: Project heading must not change - rejecting update" >> $GITHUB_STEP_SUMMARY
            return 1
          fi

          # Validation 4: Check key structural elements are preserved
          ORIGINAL_HEADING_COUNT=$(echo "$DOC_CONTENT" | grep -cE "^##\s+" || echo "0")
          NEW_HEADING_COUNT=$(echo "$CLAUDE_OUTPUT" | grep -cE "^##\s+" || echo "0")

          # Allow Â±3 heading difference (for additions, not wholesale changes)
          HEADING_DIFF=$((NEW_HEADING_COUNT - ORIGINAL_HEADING_COUNT))
          if [ $HEADING_DIFF -lt -3 ]; then
            echo "  âŒ VALIDATION FAILED: Too many sections removed ($HEADING_DIFF headings)" >> $GITHUB_STEP_SUMMARY
            echo "  âš ï¸ Content removal detected - rejecting update" >> $GITHUB_STEP_SUMMARY
            return 1
          fi

          # All validations passed
          echo "  âœ… Validation passed - updating $DOC_FILE" >> $GITHUB_STEP_SUMMARY
          echo "  ðŸ“Š Length: $INPUT_LENGTH â†’ $OUTPUT_LENGTH chars ($(( (OUTPUT_LENGTH * 100) / INPUT_LENGTH ))%)" >> $GITHUB_STEP_SUMMARY
          echo "  ðŸ“Š Sections: $ORIGINAL_HEADING_COUNT â†’ $NEW_HEADING_COUNT headings" >> $GITHUB_STEP_SUMMARY

          # Write the updated documentation
          echo "$CLAUDE_OUTPUT" > "$DOC_FILE"
          ANY_UPDATES=true
          return 0
        }

        # === PHASE 2: UPDATE ALL DETECTED DOCUMENTATION FILES ===
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "### ðŸ“ Updating Documentation Files:" >> $GITHUB_STEP_SUMMARY

        if [ "$HAS_README" = true ] && [ "$HAS_CLAUDE" = true ]; then
          echo "Both $README_FILE and $CLAUDE_FILE detected â€” updating both" >> $GITHUB_STEP_SUMMARY
          update_doc_file "$README_FILE" "README" "$CLAUDE_FILE also exists in this repository and is being updated separately for AI/Claude Code context. Focus this $README_FILE update on user-facing documentation only." || echo "  âš ï¸ Failed to update $README_FILE" >> $GITHUB_STEP_SUMMARY
          update_doc_file "$CLAUDE_FILE" "CLAUDE" "$README_FILE also exists in this repository and is being updated separately for user-facing documentation. Focus this $CLAUDE_FILE update on AI/Claude Code technical context only." || echo "  âš ï¸ Failed to update $CLAUDE_FILE" >> $GITHUB_STEP_SUMMARY
        elif [ "$HAS_README" = true ]; then
          echo "Only $README_FILE detected â€” updating $README_FILE" >> $GITHUB_STEP_SUMMARY
          update_doc_file "$README_FILE" "README" "This is the only documentation file in the repository." || echo "  âš ï¸ Failed to update $README_FILE" >> $GITHUB_STEP_SUMMARY
        elif [ "$HAS_CLAUDE" = true ]; then
          echo "Only $CLAUDE_FILE detected â€” updating $CLAUDE_FILE" >> $GITHUB_STEP_SUMMARY
          update_doc_file "$CLAUDE_FILE" "CLAUDE" "This is the only documentation file in the repository." || echo "  âš ï¸ Failed to update $CLAUDE_FILE" >> $GITHUB_STEP_SUMMARY
        fi

        # Set final output
        if [ "$ANY_UPDATES" = true ]; then
          echo "skip_analysis=false" >> $GITHUB_OUTPUT
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "ðŸ“ Documentation files have been updated" >> $GITHUB_STEP_SUMMARY
        else
          echo "skip_analysis=true" >> $GITHUB_OUTPUT
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "âš ï¸ No documentation updates were applied" >> $GITHUB_STEP_SUMMARY
        fi

    - name: ðŸ’¾ Commit Changes to PR
      id: commit-changes
      if: steps.claude-analysis.outputs.skip_analysis != 'true'
      shell: bash
      env:
        GH_TOKEN: ${{ inputs.github_token }}
        PR_NUMBER: ${{ inputs.pr_number }}
      run: |
        set -e

        # Check if documentation files were modified
        git add -A

        if git diff --cached --quiet; then
          echo "updated=false" >> $GITHUB_OUTPUT
          echo "âœ… No documentation updates needed" >> $GITHUB_STEP_SUMMARY
        else
          echo "updated=true" >> $GITHUB_OUTPUT
          echo "ðŸ“ Documentation updates detected" >> $GITHUB_STEP_SUMMARY

          # Show what changed
          echo "### Changed Files:" >> $GITHUB_STEP_SUMMARY
          echo '```' >> $GITHUB_STEP_SUMMARY
          git diff --cached --name-only >> $GITHUB_STEP_SUMMARY
          echo '```' >> $GITHUB_STEP_SUMMARY

          # Verify only documentation files changed
          CHANGED=$(git diff --cached --name-only)
          INVALID_FILES=""

          for file in $CHANGED; do
            FILE_LOWER=$(echo "$file" | tr '[:upper:]' '[:lower:]')
            if [[ "$FILE_LOWER" != "readme.md" ]] && [[ "$FILE_LOWER" != "claude.md" ]]; then
              INVALID_FILES="$INVALID_FILES $file"
            fi
          done

          if [ -n "$INVALID_FILES" ]; then
            echo "âŒ ERROR: Non-documentation files were modified:$INVALID_FILES" >> $GITHUB_STEP_SUMMARY
            echo "Only README.md and CLAUDE.md (any casing) should be updated." >> $GITHUB_STEP_SUMMARY
            git reset --hard
            echo "updated=false" >> $GITHUB_OUTPUT
            exit 1
          fi

          # Commit changes with secure git config
          git config --local user.name "github-actions[bot]"
          git config --local user.email "github-actions[bot]@users.noreply.github.com"

          # Verify configuration was set
          CONFIGURED_NAME=$(git config --local user.name)
          if [ "$CONFIGURED_NAME" != "github-actions[bot]" ]; then
            echo "âŒ Failed to set git user configuration" >> $GITHUB_STEP_SUMMARY
            exit 1
          fi

          # Validate PR number for commit message
          if ! [[ "$PR_NUMBER" =~ ^[0-9]+$ ]]; then
            echo "âŒ Invalid PR number for commit" >> $GITHUB_STEP_SUMMARY
            exit 1
          fi

          # Create commit with safe message (using printf to avoid injection)
          git commit -m "ðŸ“š DocSync AI: Apply user suggestion from comment

        Applied documentation updates based on user comment.

        Generated by DocSync AI"

          git push origin HEAD

          # Get list of changed files for comment
          CHANGED_FILES=$(git diff HEAD~1 --name-only | head -10 | sed 's/^/- /')

          # Add confirmation comment to PR using safe format
          COMMENT_BODY="âœ… **DocSync AI Update Applied**

          Your documentation suggestion has been applied and committed to this PR.

          ðŸ“ **Updated Files:**
          $CHANGED_FILES

          ---
          ðŸ¤– *Automated by DocSync AI*"

          gh pr comment "$PR_NUMBER" --body "$COMMENT_BODY"

          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### âœ… Changes Committed and Comment Added" >> $GITHUB_STEP_SUMMARY
        fi

    - name: ðŸ“Š Summary
      if: always()
      shell: bash
      env:
        VALID: ${{ steps.validate.outputs.valid }}
        IS_DOCSYNC: ${{ steps.verify-pr.outputs.is_docsync_pr }}
        UPDATED: ${{ steps.commit-changes.outputs.updated }}
      run: |
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "## ðŸ“Š Action Summary" >> $GITHUB_STEP_SUMMARY
        echo "- **Comment Valid**: ${VALID:-false}" >> $GITHUB_STEP_SUMMARY
        echo "- **Is DocSync PR**: ${IS_DOCSYNC:-false}" >> $GITHUB_STEP_SUMMARY
        echo "- **Documentation Updated**: ${UPDATED:-false}" >> $GITHUB_STEP_SUMMARY
