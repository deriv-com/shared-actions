name: "DocSync AI - Update from Comment"
description: "Update documentation based on @docbot commands on any PR"

inputs:
  github_token:
    description: "GitHub token for repository operations and PR creation"
    required: true
  anthropic_api_key:
    description: "Anthropic API key for Claude AI"
    required: true
  repository:
    description: "Repository name (owner/repo)"
    required: true
  pr_number:
    description: "PR number where comment was made"
    required: true
  comment_body:
    description: "Comment body (must start with '@docbot')"
    required: true
  comment_id:
    description: "Comment ID for adding thumbs-up reaction"
    required: false
    default: ""
  base_branch:
    description: "Base branch for documentation PR (e.g., master or main)"
    required: false
    default: "master"

outputs:
  updated:
    description: "Whether documentation was updated"
    value: "${{ steps.commit-changes.outputs.updated == 'true' || steps.revert-changes.outputs.updated == 'true' }}"
  command_valid:
    description: "Whether the comment had a valid @docbot command"
    value: "${{ steps.parse-command.outputs.valid }}"
  command:
    description: "The parsed command type"
    value: "${{ steps.parse-command.outputs.command }}"
  is_docsync_pr:
    description: "Whether the PR is a DocSync PR"
    value: "${{ steps.verify-pr.outputs.is_docsync_pr }}"

runs:
  using: composite
  steps:
    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    # STEP 1: Parse the @docbot command
    # (ðŸ‘ reaction is handled at the workflow level for instant feedback)
    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    - name: Parse Command
      id: parse-command
      shell: bash
      env:
        COMMENT_BODY: ${{ inputs.comment_body }}
        COMMENT_ID: ${{ inputs.comment_id }}
      run: |
        set -e

        echo "## Parsing @docbot Command" >> $GITHUB_STEP_SUMMARY
        echo "**Comment ID:** \`${COMMENT_ID:-N/A}\`" >> $GITHUB_STEP_SUMMARY

        # Sanitize comment body (remove null bytes, limit size)
        COMMENT_BODY_CLEAN=$(echo "$COMMENT_BODY" | tr -d '\000' | iconv -c -t UTF-8//IGNORE | head -c 10000)

        # Validate for suspicious patterns
        if echo "$COMMENT_BODY_CLEAN" | grep -qE '\$\(|\`|;[[:space:]]*curl|;[[:space:]]*wget|eval|exec'; then
          echo "Warning: Suspicious pattern detected in comment" >> $GITHUB_STEP_SUMMARY
        fi

        # Check if first line starts with "@docbot" (case-insensitive)
        FIRST_LINE=$(echo "$COMMENT_BODY_CLEAN" | head -1)
        if ! echo "$FIRST_LINE" | grep -qiE "^@docbot([[:space:]]|$)"; then
          echo "valid=false" >> $GITHUB_OUTPUT
          echo "command=none" >> $GITHUB_OUTPUT
          echo "Comment does not start with '@docbot' - skipping" >> $GITHUB_STEP_SUMMARY
          exit 0
        fi

        echo "valid=true" >> $GITHUB_OUTPUT

        # Extract everything after "@docbot "
        INSTRUCTION=$(echo "$COMMENT_BODY_CLEAN" | sed -E '1s/^@[Dd][Oo][Cc][Bb][Oo][Tt][[:space:]]*//')
        # Trim leading blank lines
        INSTRUCTION=$(echo "$INSTRUCTION" | sed '/./,$!d')

        # Parse structured commands (case-insensitive)
        INSTRUCTION_LOWER=$(echo "$INSTRUCTION" | tr '[:upper:]' '[:lower:]' | head -1)

        # â”€â”€â”€ revert last change â”€â”€â”€
        if echo "$INSTRUCTION_LOWER" | grep -qE "^revert[[:space:]]+last[[:space:]]+change[s]?[[:space:]]*$"; then
          echo "command=revert_last" >> $GITHUB_OUTPUT
          echo "target_file=all" >> $GITHUB_OUTPUT
          echo "### Command: \`revert last change\`" >> $GITHUB_STEP_SUMMARY

        # â”€â”€â”€ revert to <commit-hash> â”€â”€â”€
        elif echo "$INSTRUCTION_LOWER" | grep -qE "^revert[[:space:]]+to[[:space:]]"; then
          TARGET_HASH=$(echo "$INSTRUCTION" | head -1 | sed -E "s/^[Rr][Ee][Vv][Ee][Rr][Tt][[:space:]]+[Tt][Oo][[:space:]]+['\"]?([a-fA-F0-9]+)['\"]?[[:space:]]*$/\1/")
          if [[ "$TARGET_HASH" =~ ^[a-fA-F0-9]{7,40}$ ]]; then
            echo "command=revert_to" >> $GITHUB_OUTPUT
            echo "target_hash=$TARGET_HASH" >> $GITHUB_OUTPUT
            echo "target_file=all" >> $GITHUB_OUTPUT
            echo "### Command: \`revert to $TARGET_HASH\`" >> $GITHUB_STEP_SUMMARY
          else
            echo "valid=false" >> $GITHUB_OUTPUT
            echo "command=none" >> $GITHUB_OUTPUT
            echo "Invalid commit hash format" >> $GITHUB_STEP_SUMMARY
            exit 0
          fi

        # â”€â”€â”€ update only readme.md <instruction> â”€â”€â”€
        elif echo "$INSTRUCTION_LOWER" | grep -qE "^update[[:space:]]+only[[:space:]]+readme(\.md)?([[:space:]]|$)"; then
          SUGGESTION=$(echo "$INSTRUCTION" | sed -E 's/^[Uu][Pp][Dd][Aa][Tt][Ee][[:space:]]+[Oo][Nn][Ll][Yy][[:space:]]+[Rr][Ee][Aa][Dd][Mm][Ee](\.md)?[[:space:]]*//')
          if [ -z "$SUGGESTION" ]; then
            SUGGESTION="Update and improve the documentation"
          fi
          echo "command=update" >> $GITHUB_OUTPUT
          echo "target_file=readme" >> $GITHUB_OUTPUT
          echo "suggestion<<EOF" >> $GITHUB_OUTPUT
          echo "$SUGGESTION" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT
          echo "### Command: \`update only readme.md\`" >> $GITHUB_STEP_SUMMARY

        # â”€â”€â”€ update only claude.md <instruction> â”€â”€â”€
        elif echo "$INSTRUCTION_LOWER" | grep -qE "^update[[:space:]]+only[[:space:]]+claude(\.md)?([[:space:]]|$)"; then
          SUGGESTION=$(echo "$INSTRUCTION" | sed -E 's/^[Uu][Pp][Dd][Aa][Tt][Ee][[:space:]]+[Oo][Nn][Ll][Yy][[:space:]]+[Cc][Ll][Aa][Uu][Dd][Ee](\.md)?[[:space:]]*//')
          if [ -z "$SUGGESTION" ]; then
            SUGGESTION="Update and improve the technical documentation"
          fi
          echo "command=update" >> $GITHUB_OUTPUT
          echo "target_file=claude" >> $GITHUB_OUTPUT
          echo "suggestion<<EOF" >> $GITHUB_OUTPUT
          echo "$SUGGESTION" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT
          echo "### Command: \`update only claude.md\`" >> $GITHUB_STEP_SUMMARY

        # â”€â”€â”€ general update <instruction> â”€â”€â”€
        else
          if [ -z "$INSTRUCTION" ]; then
            echo "valid=false" >> $GITHUB_OUTPUT
            echo "command=none" >> $GITHUB_OUTPUT
            echo "Empty instruction after @docbot" >> $GITHUB_STEP_SUMMARY
            exit 0
          fi
          echo "command=update" >> $GITHUB_OUTPUT
          echo "target_file=all" >> $GITHUB_OUTPUT
          echo "suggestion<<EOF" >> $GITHUB_OUTPUT
          echo "$INSTRUCTION" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT
          echo "### Command: \`update\`" >> $GITHUB_STEP_SUMMARY
        fi

        # Display instruction for summary
        INSTRUCTION_DISPLAY=$(echo "$INSTRUCTION" | head -c 500)
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "**Instruction:**" >> $GITHUB_STEP_SUMMARY
        echo '```' >> $GITHUB_STEP_SUMMARY
        echo "$INSTRUCTION_DISPLAY" >> $GITHUB_STEP_SUMMARY
        echo '```' >> $GITHUB_STEP_SUMMARY

    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    # STEP 3: Verify PR type
    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    - name: Verify PR Type
      id: verify-pr
      if: steps.parse-command.outputs.valid == 'true'
      shell: bash
      env:
        GH_TOKEN: ${{ inputs.github_token }}
        PR_NUMBER: ${{ inputs.pr_number }}
        REPO_NAME: ${{ inputs.repository }}
      run: |
        set -e

        echo "## Verifying PR" >> $GITHUB_STEP_SUMMARY

        # Validate PR number
        if ! [[ "$PR_NUMBER" =~ ^[0-9]+$ ]]; then
          echo "Invalid PR number: $PR_NUMBER" >> $GITHUB_STEP_SUMMARY
          exit 1
        fi

        if [ "$PR_NUMBER" -lt 1 ] || [ "$PR_NUMBER" -gt 999999 ]; then
          echo "PR number out of valid range: $PR_NUMBER" >> $GITHUB_STEP_SUMMARY
          exit 1
        fi

        # Validate repository format
        if ! [[ "$REPO_NAME" =~ ^[a-zA-Z0-9_-]+/[a-zA-Z0-9_.-]+$ ]]; then
          echo "Invalid repository format: $REPO_NAME" >> $GITHUB_STEP_SUMMARY
          exit 1
        fi

        # Get PR details including labels and title
        PR_DATA=$(gh api \
          -H "Accept: application/vnd.github+json" \
          "/repos/$REPO_NAME/pulls/$PR_NUMBER")

        # Validate response is valid JSON
        if ! echo "$PR_DATA" | jq empty 2>/dev/null; then
          echo "Invalid response from GitHub API" >> $GITHUB_STEP_SUMMARY
          exit 1
        fi

        # Extract labels
        PR_LABELS=$(echo "$PR_DATA" | jq -r '.labels[].name' 2>&1 || echo "")

        # Extract PR title and sanitize
        PR_TITLE=$(echo "$PR_DATA" | jq -r '.title' 2>&1 || echo "")
        PR_TITLE=$(echo "$PR_TITLE" | tr -d '\000-\037' | head -c 200)

        # Extract PR branch and validate
        PR_BRANCH=$(echo "$PR_DATA" | jq -r '.head.ref' 2>&1 || echo "")

        # Validate branch name format
        if ! [[ "$PR_BRANCH" =~ ^[a-zA-Z0-9/_.-]+$ ]]; then
          echo "Invalid branch name format" >> $GITHUB_STEP_SUMMARY
          exit 1
        fi

        # Sanitize labels for display
        PR_LABELS_DISPLAY=$(echo "$PR_LABELS" | head -n 10)

        echo "### PR Information:" >> $GITHUB_STEP_SUMMARY
        echo "- **Title**: ${PR_TITLE:0:100}" >> $GITHUB_STEP_SUMMARY
        echo "- **Branch**: $PR_BRANCH" >> $GITHUB_STEP_SUMMARY
        echo "- **Labels**: ${PR_LABELS_DISPLAY:-'(none)'}" >> $GITHUB_STEP_SUMMARY

        # Check if PR has docsync-ai or automated label, OR if title contains "DocSync"
        IS_DOCSYNC_PR=false

        if echo "$PR_LABELS" | grep -qE "(docsync-ai|automated)"; then
          IS_DOCSYNC_PR=true
          echo "PR has DocSync label" >> $GITHUB_STEP_SUMMARY
        elif echo "$PR_TITLE" | grep -qi "docsync"; then
          IS_DOCSYNC_PR=true
          echo "PR title contains 'DocSync'" >> $GITHUB_STEP_SUMMARY
        fi

        echo "is_docsync_pr=$IS_DOCSYNC_PR" >> $GITHUB_OUTPUT
        echo "pr_branch=$PR_BRANCH" >> $GITHUB_OUTPUT
        echo "pr_title=$PR_TITLE" >> $GITHUB_OUTPUT

        if [ "$IS_DOCSYNC_PR" = true ]; then
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**DocSync PR detected** - will apply user instruction directly" >> $GITHUB_STEP_SUMMARY
        else
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Regular PR detected** - will analyze PR changes and update documentation" >> $GITHUB_STEP_SUMMARY
        fi

    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    # STEP 4: Checkout PR branch
    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    - name: Checkout PR Branch
      if: steps.parse-command.outputs.valid == 'true'
      uses: actions/checkout@v4
      with:
        token: ${{ inputs.github_token }}
        ref: ${{ steps.verify-pr.outputs.pr_branch }}
        fetch-depth: 0

    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    # STEP 5: Handle revert commands
    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    - name: Handle Revert Commands
      id: revert-changes
      if: steps.parse-command.outputs.valid == 'true' && (steps.parse-command.outputs.command == 'revert_last' || steps.parse-command.outputs.command == 'revert_to')
      shell: bash
      env:
        GH_TOKEN: ${{ inputs.github_token }}
        PR_NUMBER: ${{ inputs.pr_number }}
        REPO_NAME: ${{ inputs.repository }}
        COMMAND: ${{ steps.parse-command.outputs.command }}
        TARGET_HASH: ${{ steps.parse-command.outputs.target_hash }}
      run: |
        set -e

        echo "## Handling Revert" >> $GITHUB_STEP_SUMMARY

        # Configure git
        git config --local user.name "github-actions[bot]"
        git config --local user.email "github-actions[bot]@users.noreply.github.com"

        if [ "$COMMAND" = "revert_last" ]; then
          echo "### Reverting last DocSync change" >> $GITHUB_STEP_SUMMARY

          # Find the last DocSync AI commit on this branch
          LAST_DOCSYNC_COMMIT=$(git log --author="github-actions\[bot\]" --grep="DocSync AI" --format="%H" -1 2>/dev/null || echo "")

          if [ -z "$LAST_DOCSYNC_COMMIT" ]; then
            echo "No DocSync AI commit found to revert" >> $GITHUB_STEP_SUMMARY
            echo "updated=false" >> $GITHUB_OUTPUT

            # Post comment informing user
            gh pr comment "$PR_NUMBER" --body "**@docbot** No previous DocSync AI commit found to revert on this branch."
            exit 0
          fi

          COMMIT_MSG=$(git log --format="%s" -1 "$LAST_DOCSYNC_COMMIT" | head -c 200)
          COMMIT_SHORT=$(echo "$LAST_DOCSYNC_COMMIT" | cut -c1-7)
          echo "Found commit: \`$COMMIT_SHORT\` â€” $COMMIT_MSG" >> $GITHUB_STEP_SUMMARY

          # Revert the commit
          if git revert --no-edit "$LAST_DOCSYNC_COMMIT"; then
            git push origin HEAD

            echo "updated=true" >> $GITHUB_OUTPUT
            echo "âœ… Successfully reverted" >> $GITHUB_STEP_SUMMARY

            # Post confirmation comment
            COMMENT_BODY="**DocSync AI â€” Revert Applied** :rewind:

        Reverted commit \`$COMMIT_SHORT\`: $COMMIT_MSG

        ---
        *Automated by DocSync AI*"
            gh pr comment "$PR_NUMBER" --body "$COMMENT_BODY"
          else
            echo "updated=false" >> $GITHUB_OUTPUT
            echo "âŒ Revert failed (possible conflicts)" >> $GITHUB_STEP_SUMMARY
            git revert --abort 2>/dev/null || true

            gh pr comment "$PR_NUMBER" --body "**@docbot** Revert failed due to conflicts. Please revert manually."
          fi

        elif [ "$COMMAND" = "revert_to" ]; then
          echo "### Reverting documentation to commit \`$TARGET_HASH\`" >> $GITHUB_STEP_SUMMARY

          # Validate hash format
          if ! [[ "$TARGET_HASH" =~ ^[a-fA-F0-9]{7,40}$ ]]; then
            echo "Invalid commit hash format" >> $GITHUB_STEP_SUMMARY
            echo "updated=false" >> $GITHUB_OUTPUT
            exit 1
          fi

          # Validate the commit exists
          if ! git cat-file -e "$TARGET_HASH" 2>/dev/null; then
            echo "Commit \`$TARGET_HASH\` not found in history" >> $GITHUB_STEP_SUMMARY
            echo "updated=false" >> $GITHUB_OUTPUT
            gh pr comment "$PR_NUMBER" --body "**@docbot** Commit \`$TARGET_HASH\` not found in this branch's history."
            exit 0
          fi

          TARGET_SHORT=$(echo "$TARGET_HASH" | cut -c1-7)

          # Find documentation files in the current checkout
          README_FILE=$(find . -maxdepth 1 -type f -iname "readme.md" -print -quit 2>/dev/null)
          CLAUDE_FILE=$(find . -maxdepth 1 -type f -iname "claude.md" -print -quit 2>/dev/null)

          RESTORED_FILES=""

          # Restore doc files from the target commit
          if [ -n "$README_FILE" ]; then
            README_FILE="${README_FILE#./}"
            if git checkout "$TARGET_HASH" -- "$README_FILE" 2>/dev/null; then
              RESTORED_FILES="$RESTORED_FILES $README_FILE"
            fi
          fi

          if [ -n "$CLAUDE_FILE" ]; then
            CLAUDE_FILE="${CLAUDE_FILE#./}"
            if git checkout "$TARGET_HASH" -- "$CLAUDE_FILE" 2>/dev/null; then
              RESTORED_FILES="$RESTORED_FILES $CLAUDE_FILE"
            fi
          fi

          if [ -z "$RESTORED_FILES" ]; then
            echo "No documentation files found at commit \`$TARGET_SHORT\`" >> $GITHUB_STEP_SUMMARY
            echo "updated=false" >> $GITHUB_OUTPUT
            gh pr comment "$PR_NUMBER" --body "**@docbot** No documentation files (README.md / CLAUDE.md) found at commit \`$TARGET_SHORT\`."
            exit 0
          fi

          # Verify only doc files changed
          git add -A
          CHANGED=$(git diff --cached --name-only)
          for file in $CHANGED; do
            FILE_LOWER=$(echo "$file" | tr '[:upper:]' '[:lower:]')
            if [[ "$FILE_LOWER" != "readme.md" ]] && [[ "$FILE_LOWER" != "claude.md" ]]; then
              echo "ERROR: Non-documentation file changed: $file" >> $GITHUB_STEP_SUMMARY
              git reset --hard
              echo "updated=false" >> $GITHUB_OUTPUT
              exit 1
            fi
          done

          if git diff --cached --quiet; then
            echo "Documentation already matches commit \`$TARGET_SHORT\`" >> $GITHUB_STEP_SUMMARY
            echo "updated=false" >> $GITHUB_OUTPUT
            gh pr comment "$PR_NUMBER" --body "**@docbot** Documentation already matches commit \`$TARGET_SHORT\`. No changes needed."
            exit 0
          fi

          git commit -m "DocSync AI: Revert documentation to $TARGET_SHORT

        Restored documentation files to the state at commit $TARGET_HASH.

        Generated by DocSync AI"
          git push origin HEAD

          echo "updated=true" >> $GITHUB_OUTPUT
          echo "âœ… Restored documentation to \`$TARGET_SHORT\`" >> $GITHUB_STEP_SUMMARY

          # Post confirmation comment
          CHANGED_LIST=$(echo "$RESTORED_FILES" | tr ' ' '\n' | sed '/^$/d' | sed 's/^/- /')
          COMMENT_BODY="**DocSync AI â€” Reverted to \`$TARGET_SHORT\`** :rewind:

        Documentation files restored to commit \`$TARGET_HASH\`.

        **Restored Files:**
        $CHANGED_LIST

        ---
        *Automated by DocSync AI*"
          gh pr comment "$PR_NUMBER" --body "$COMMENT_BODY"
        fi

    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    # STEP 6: Fetch PR diff (update on regular PRs)
    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    - name: Fetch PR Diff for Regular PRs
      id: fetch-diff
      if: >
        steps.parse-command.outputs.valid == 'true' &&
        steps.parse-command.outputs.command == 'update' &&
        steps.verify-pr.outputs.is_docsync_pr != 'true'
      shell: bash
      env:
        GH_TOKEN: ${{ inputs.github_token }}
        PR_NUMBER: ${{ inputs.pr_number }}
        REPO_NAME: ${{ inputs.repository }}
      run: |
        set -e

        echo "## Fetching PR Diff" >> $GITHUB_STEP_SUMMARY

        # Create secure temporary directory
        TEMP_DIR=$(mktemp -d -t docsync-diff-XXXXXXXXXX)
        echo "temp_dir=$TEMP_DIR" >> $GITHUB_OUTPUT

        # Get full PR diff
        PR_DIFF=$(gh api \
          -H "Accept: application/vnd.github.v3.diff" \
          "/repos/$REPO_NAME/pulls/$PR_NUMBER" 2>&1)

        # Sanitize and validate diff content
        PR_DIFF=$(echo "$PR_DIFF" | tr -d '\000' | iconv -c -t UTF-8//IGNORE)

        # Filter out .github/workflows diffs
        PR_DIFF=$(echo "$PR_DIFF" | awk '
          BEGIN { skip=0 }
          /^diff --git.*\.github\/workflows\// { skip=1; next }
          /^diff --git/ { skip=0 }
          !skip { print }
        ')

        # Save PR diff to secure temp file
        echo "$PR_DIFF" > "$TEMP_DIR/pr_diff.txt"
        chmod 600 "$TEMP_DIR/pr_diff.txt"

        # Get list of changed files
        CHANGED_FILES=$(gh api \
          -H "Accept: application/vnd.github+json" \
          "/repos/$REPO_NAME/pulls/$PR_NUMBER/files" \
          --jq '.[].filename' 2>&1 || echo "")

        # Filter out .github/workflows files
        CHANGED_FILES_FILTERED=$(echo "$CHANGED_FILES" | grep -v '^\.github/workflows/' || echo "")

        # Check if all changes were in workflows
        if [ -n "$CHANGED_FILES" ] && [ -z "$CHANGED_FILES_FILTERED" ]; then
          echo "All changes are in .github/workflows - skipping documentation update" >> $GITHUB_STEP_SUMMARY
          echo "skip_diff=true" >> $GITHUB_OUTPUT
          rm -rf "$TEMP_DIR"
          exit 0
        fi

        echo "skip_diff=false" >> $GITHUB_OUTPUT

        echo "### Changed Files (excluding workflows):" >> $GITHUB_STEP_SUMMARY
        echo '```' >> $GITHUB_STEP_SUMMARY
        echo "$CHANGED_FILES_FILTERED" | head -n 50 >> $GITHUB_STEP_SUMMARY
        echo '```' >> $GITHUB_STEP_SUMMARY

    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    # STEP 7: Run Claude analysis (update)
    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    - name: Run Claude Sonnet 4.5 Documentation Analysis
      id: claude-analysis
      if: >
        steps.parse-command.outputs.valid == 'true' &&
        steps.parse-command.outputs.command == 'update' &&
        steps.fetch-diff.outputs.skip_diff != 'true'
      shell: bash
      env:
        ANTHROPIC_API_KEY: ${{ inputs.anthropic_api_key }}
        REPO_NAME: ${{ inputs.repository }}
        PR_NUMBER: ${{ inputs.pr_number }}
        USER_SUGGESTION: ${{ steps.parse-command.outputs.suggestion }}
        IS_DOCSYNC_PR: ${{ steps.verify-pr.outputs.is_docsync_pr }}
        PR_TITLE: ${{ steps.verify-pr.outputs.pr_title }}
        DIFF_TEMP_DIR: ${{ steps.fetch-diff.outputs.temp_dir }}
        TARGET_FILE: ${{ steps.parse-command.outputs.target_file }}
      run: |
        set -e

        echo "## Claude Sonnet 4.5 Analysis" >> $GITHUB_STEP_SUMMARY
        echo "Model: claude-sonnet-4-5" >> $GITHUB_STEP_SUMMARY
        echo "Target: $TARGET_FILE" >> $GITHUB_STEP_SUMMARY

        # Create secure temporary directory
        TEMP_DIR=$(mktemp -d -t docsync-comment-XXXXXXXXXX)
        trap "rm -rf '$TEMP_DIR'" EXIT

        # Sanitize user suggestion
        USER_SUGGESTION_CLEAN=$(echo "$USER_SUGGESTION" | tr -d '\000' | iconv -c -t UTF-8//IGNORE | head -c 10000)

        # For regular PRs, read the diff
        PR_DIFF=""
        if [ "$IS_DOCSYNC_PR" != "true" ] && [ -n "$DIFF_TEMP_DIR" ] && [ -f "$DIFF_TEMP_DIR/pr_diff.txt" ]; then
          PR_DIFF=$(cat "$DIFF_TEMP_DIR/pr_diff.txt")
        fi

        # === DIFF SIZE MANAGEMENT ===
        # If the PR diff exceeds Claude's context window, chunk and summarize
        MAX_DIFF_CHARS=600000
        CHUNK_MAX_CHARS=500000
        DIFF_SIZE=${#PR_DIFF}

        if [ "$DIFF_SIZE" -gt "$MAX_DIFF_CHARS" ]; then
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Large Diff Detected" >> $GITHUB_STEP_SUMMARY
          echo "PR diff is $DIFF_SIZE chars (limit: $MAX_DIFF_CHARS). Chunking and summarizing..." >> $GITHUB_STEP_SUMMARY

          CHUNK_DIR="$TEMP_DIR/diff_chunks"
          rm -rf "$CHUNK_DIR"
          mkdir -p "$CHUNK_DIR"

          # Determine diff source file
          DIFF_SOURCE_FILE=""
          if [ -n "$DIFF_TEMP_DIR" ] && [ -f "$DIFF_TEMP_DIR/pr_diff.txt" ]; then
            DIFF_SOURCE_FILE="$DIFF_TEMP_DIR/pr_diff.txt"
          else
            DIFF_SOURCE_FILE="$TEMP_DIR/diff_source.txt"
            printf '%s' "$PR_DIFF" > "$DIFF_SOURCE_FILE"
          fi

          # Split diff into chunks at "diff --git" boundaries, each â‰¤ CHUNK_MAX_CHARS
          awk -v max="$CHUNK_MAX_CHARS" -v dir="$CHUNK_DIR" '
            BEGIN { chunk=1; size=0; file=dir "/chunk_1.txt" }
            /^diff --git / {
              if (size > max && size > 0) {
                close(file)
                chunk++
                size=0
                file=dir "/chunk_" chunk ".txt"
              }
            }
            { print >> file; size += length($0) + 1 }
            END { close(file); print chunk > dir "/chunk_count.txt" }
          ' "$DIFF_SOURCE_FILE"

          TOTAL_CHUNKS=$(cat "$CHUNK_DIR/chunk_count.txt" 2>/dev/null || echo "1")
          echo "Split into $TOTAL_CHUNKS chunk(s)" >> $GITHUB_STEP_SUMMARY

          ALL_SUMMARIES=""
          for i in $(seq 1 "$TOTAL_CHUNKS"); do
            CHUNK_PATH="$CHUNK_DIR/chunk_${i}.txt"
            [ -f "$CHUNK_PATH" ] || continue
            CHUNK_BYTES=$(wc -c < "$CHUNK_PATH" | tr -d ' ')
            echo "  Summarizing chunk $i/$TOTAL_CHUNKS (~$CHUNK_BYTES chars)..." >> $GITHUB_STEP_SUMMARY

            # Build summarization prompt
            SPROMPT_FILE="$TEMP_DIR/sprompt_${i}.txt"
            {
              echo "You are analyzing code changes to identify documentation-relevant updates for root-level project documentation (README.md / CLAUDE.md)."
              echo ""
              echo "Repository: $REPO_NAME"
              echo ""
              echo "Review the code diff below and extract ONLY changes that would affect root-level project documentation:"
              echo "- New features, modules, or public APIs"
              echo "- Breaking changes or changed behavior"
              echo "- New dependencies"
              echo "- Major configuration changes"
              echo "- Changes to project setup, installation, or usage"
              echo ""
              echo "For each doc-relevant change found, provide:"
              echo "1. A concise description of what changed"
              echo "2. The files involved"
              echo "3. Why it matters for root-level documentation"
              echo ""
              echo "If nothing in this diff chunk is relevant to root-level documentation, output exactly: NO_DOC_RELEVANT_CHANGES"
              echo ""
              echo "Code diff (chunk $i of $TOTAL_CHUNKS):"
              echo '```diff'
              cat "$CHUNK_PATH"
              echo '```'
            } > "$SPROMPT_FILE"
            chmod 600 "$SPROMPT_FILE"

            # Build API request
            SREQUEST_FILE="$TEMP_DIR/srequest_${i}.json"
            jq -n \
              --arg model "claude-sonnet-4-5" \
              --argjson max_tokens 4096 \
              --rawfile content "$SPROMPT_FILE" \
              '{
                model: $model,
                max_tokens: $max_tokens,
                messages: [{
                  role: "user",
                  content: $content
                }]
              }' > "$SREQUEST_FILE"
            chmod 600 "$SREQUEST_FILE"

            # Call Claude API for chunk summarization
            SRESPONSE=$(curl -s https://api.anthropic.com/v1/messages \
              -H "content-type: application/json" \
              -H "x-api-key: $ANTHROPIC_API_KEY" \
              -H "anthropic-version: 2023-06-01" \
              -d @"$SREQUEST_FILE")

            rm -f "$SREQUEST_FILE" "$SPROMPT_FILE"

            # Validate response
            if ! echo "$SRESPONSE" | jq empty 2>/dev/null; then
              echo "  Warning: Invalid response for chunk $i" >> $GITHUB_STEP_SUMMARY
              continue
            fi

            if echo "$SRESPONSE" | jq -e '.error' > /dev/null 2>&1; then
              SERR_TYPE=$(echo "$SRESPONSE" | jq -r '.error.type // "unknown"')
              echo "  Warning: API error for chunk $i: $SERR_TYPE" >> $GITHUB_STEP_SUMMARY
              continue
            fi

            CHUNK_SUMMARY=$(echo "$SRESPONSE" | jq -r '.content[0].text // ""' | tr -d '\000' | iconv -c -t UTF-8//IGNORE)

            if [ -n "$CHUNK_SUMMARY" ] && ! echo "$CHUNK_SUMMARY" | grep -q "NO_DOC_RELEVANT_CHANGES"; then
              ALL_SUMMARIES="${ALL_SUMMARIES}

        --- Chunk $i Analysis ---
        ${CHUNK_SUMMARY}"
              echo "  Chunk $i: doc-relevant changes found" >> $GITHUB_STEP_SUMMARY
            else
              echo "  Chunk $i: no doc-relevant changes" >> $GITHUB_STEP_SUMMARY
            fi
          done

          rm -rf "$CHUNK_DIR"

          # Replace PR_DIFF with summaries for the update prompt
          if [ -n "$ALL_SUMMARIES" ]; then
            PR_DIFF="[SUMMARIZED â€” Original diff was ${DIFF_SIZE} chars. Each chunk was analyzed by Claude Sonnet 4.5 for documentation-relevant changes.]
        ${ALL_SUMMARIES}"
            echo "Diff chunking complete â€” summaries ready for update prompt" >> $GITHUB_STEP_SUMMARY
          else
            PR_DIFF="[ANALYZED â€” Original diff was ${DIFF_SIZE} chars across $TOTAL_CHUNKS chunks. No documentation-relevant changes were identified in any chunk.]"
            echo "No doc-relevant changes found in any chunk" >> $GITHUB_STEP_SUMMARY
          fi
        else
          if [ "$DIFF_SIZE" -gt 0 ]; then
            echo "Diff size: $DIFF_SIZE chars (within context limits)" >> $GITHUB_STEP_SUMMARY
          fi
        fi

        # Sanitize PR title
        PR_TITLE_CLEAN=$(echo "$PR_TITLE" | tr -d '\000-\037' | head -c 200)

        # Validate file paths helper function
        validate_doc_file() {
          local file=$1
          if [[ ! -f "$file" ]] || [[ -L "$file" ]]; then
            return 1
          fi
          local basename=$(basename "$file")
          local basename_lower=$(echo "$basename" | tr '[:upper:]' '[:lower:]')
          if [[ "$basename_lower" != "readme.md" ]] && [[ "$basename_lower" != "claude.md" ]]; then
            return 1
          fi
          local realpath=$(realpath "$file" 2>/dev/null || echo "")
          local workdir=$(realpath . 2>/dev/null || echo "")
          if [[ ! "$realpath" == "$workdir"/* ]]; then
            return 1
          fi
          return 0
        }

        # === PHASE 1: DETECT DOCUMENTATION FILES ===
        HAS_README=false
        HAS_CLAUDE=false

        README_FILE=$(find . -maxdepth 1 -type f -iname "readme.md" -print -quit 2>/dev/null)
        if [ -n "$README_FILE" ]; then
          README_FILE="${README_FILE#./}"
          if validate_doc_file "$README_FILE"; then
            HAS_README=true
          else
            echo "Invalid README file detected, skipping" >> $GITHUB_STEP_SUMMARY
            README_FILE=""
          fi
        fi

        CLAUDE_FILE=$(find . -maxdepth 1 -type f -iname "claude.md" -print -quit 2>/dev/null)
        if [ -n "$CLAUDE_FILE" ]; then
          CLAUDE_FILE="${CLAUDE_FILE#./}"
          if validate_doc_file "$CLAUDE_FILE"; then
            HAS_CLAUDE=true
          else
            echo "Invalid CLAUDE file detected, skipping" >> $GITHUB_STEP_SUMMARY
            CLAUDE_FILE=""
          fi
        fi

        # Apply target file filter
        if [ "$TARGET_FILE" = "readme" ]; then
          HAS_CLAUDE=false
          echo "ðŸŽ¯ Target file filter: **README.md only**" >> $GITHUB_STEP_SUMMARY
        elif [ "$TARGET_FILE" = "claude" ]; then
          HAS_README=false
          echo "ðŸŽ¯ Target file filter: **CLAUDE.md only**" >> $GITHUB_STEP_SUMMARY
        fi

        echo "### Documentation File Detection:" >> $GITHUB_STEP_SUMMARY
        echo "- README.md: $([ "$HAS_README" = true ] && echo "Found ($README_FILE)" || echo 'Skipped / Not found')" >> $GITHUB_STEP_SUMMARY
        echo "- CLAUDE.md: $([ "$HAS_CLAUDE" = true ] && echo "Found ($CLAUDE_FILE)" || echo 'Skipped / Not found')" >> $GITHUB_STEP_SUMMARY

        if [ "$HAS_README" = false ] && [ "$HAS_CLAUDE" = false ]; then
          echo "No matching documentation file found" >> $GITHUB_STEP_SUMMARY
          echo "skip_analysis=true" >> $GITHUB_OUTPUT
          exit 0
        fi

        # Get repository structure for regular PRs
        REPO_STRUCTURE=""
        if [ "$IS_DOCSYNC_PR" != "true" ]; then
          REPO_STRUCTURE=$(find . -maxdepth 3 -type f \
            \( -name "*.js" -o -name "*.ts" -o -name "*.jsx" -o -name "*.tsx" -o -name "*.py" -o -name "*.go" -o -name "*.java" -o -name "*.yml" -o -name "*.yaml" \) \
            -not -path "*/node_modules/*" \
            -not -path "*/.git/*" \
            -not -path "*/vendor/*" \
            -not -path "*/dist/*" \
            -not -path "*/build/*" \
            -not -name "*secret*" \
            -not -name "*credential*" \
            -not -name "*.env*" \
            2>/dev/null | head -30 | sed 's|^\./||' || echo "")
        fi

        ANY_UPDATES=false

        # Function to call Claude API for documentation update
        update_doc_file() {
          local DOC_FILE=$1
          local DOC_FORMAT=$2
          local OTHER_FILES_NOTE=$3

          echo "Processing $DOC_FILE..." >> $GITHUB_STEP_SUMMARY

          if ! validate_doc_file "$DOC_FILE"; then
            echo "  Invalid doc file: $DOC_FILE" >> $GITHUB_STEP_SUMMARY
            return 1
          fi

          DOC_CONTENT=$(cat "$DOC_FILE")

          PROJECT_TITLE=$(echo "$DOC_CONTENT" | head -n 30 | grep -E "^#\s+" | head -n 1 | sed 's/^#*\s*//' | tr -d '\000-\037' | head -c 200)
          if [ -z "$PROJECT_TITLE" ]; then
            PROJECT_TITLE="Unknown Project"
          fi

          KEY_TERMS=$(echo "$DOC_CONTENT" | head -n 100 | grep -oE '\b[A-Z][A-Za-z0-9]{3,}\b' | sort -u | head -n 20 | tr '\n' ',' | sed 's/,$//')

          echo "  Project: $PROJECT_TITLE" >> $GITHUB_STEP_SUMMARY

          if [ "$DOC_FORMAT" = "README" ]; then
            FORMAT_INSTRUCTION="This is a README.md file. Maintain standard README format with clear sections, proper markdown formatting, badges, installation instructions, usage examples, and project overview. Keep the professional, user-facing documentation style."
          else
            FORMAT_INSTRUCTION="This is a CLAUDE.md file for AI assistance. Maintain the technical, detailed format suitable for AI context with implementation details, architecture notes, and development guidelines. Keep the detailed, technical documentation style."
          fi

          PROMPT_FILE="$TEMP_DIR/claude_prompt_$(openssl rand -hex 8).txt"

          if [ "$IS_DOCSYNC_PR" = "true" ]; then
            {
              echo "You are a technical documentation expert. A user has provided a suggestion for improving the documentation in a DocSync PR."
              echo ""
              echo "## IMPORTANT: PROJECT IDENTITY"
              echo "This documentation is for: $PROJECT_TITLE"
              echo "Repository: $REPO_NAME"
              echo ""
              echo "**CRITICAL**: You MUST maintain the project identity. This is NOT a different project. Do NOT replace this documentation with content about any other project, library, or tool."
              echo ""
              echo "**ROOT-LEVEL DOCS**: These are the root-level documentation files for the entire repository. They should contain only high-level, project-wide information that matters to users and contributors â€” NOT granular implementation details of individual files, functions, or internal logic."
              echo ""
              echo "## Context"
              echo "PR #$PR_NUMBER (DocSync Documentation PR)"
              echo ""
              echo "## Current Documentation Content:"
              echo '```'
              echo "$DOC_CONTENT"
              echo '```'
              echo ""
              echo "## User Instruction:"
              echo '```'
              echo "$USER_SUGGESTION_CLEAN"
              echo '```'
              echo ""
              echo "## Format Requirements:"
              echo "$FORMAT_INSTRUCTION"
              echo ""
              echo "## Additional Context:"
              echo "$OTHER_FILES_NOTE"
              echo ""
              echo "## Your Task"
              echo "Apply the user instruction to update the $DOC_FILE while maintaining project identity and existing content."
              echo ""
              echo "## ABSOLUTE REQUIREMENTS - VIOLATION WILL BE REJECTED:"
              echo ""
              echo "1. **PRESERVE PROJECT IDENTITY**:"
              echo "   - The project name \"$PROJECT_TITLE\" MUST remain unchanged"
              echo "   - Do NOT replace this with documentation for a different project"
              echo "   - Maintain all existing project-specific information"
              echo ""
              echo "2. **ONLY ADD OR REFINE, NEVER REMOVE**:"
              echo "   - Apply the user instruction by adding or refining content"
              echo "   - NEVER remove existing sections, features, or content unless explicitly requested"
              echo "   - NEVER replace existing content with unrelated information"
              echo "   - Keep all existing headings, sections, and structure intact"
              echo ""
              echo "3. **FOLLOW USER INTENT**:"
              echo "   - Carefully interpret and apply the user instruction"
              echo "   - If the instruction is about adding content, add it to the appropriate section"
              echo "   - If it is about improving clarity, refine the existing text"
              echo "   - If it is vague, make conservative, relevant improvements"
              echo ""
              echo "4. **VERIFY PROJECT MATCH**:"
              echo "   - Ensure any additions are relevant to \"$PROJECT_TITLE\" in \"$REPO_NAME\""
              echo "   - Do NOT add information about unrelated projects or technologies"
              echo "   - Maintain consistency with existing content"
              echo ""
              echo "5. **OUTPUT FORMAT**:"
              echo "   - Output ONLY the complete updated documentation content"
              echo "   - NO preambles, acknowledgments, or explanatory text"
              echo '   - NO phrases like "Here is the updated", "I have applied", etc.'
              echo "   - Start directly with the documentation content"
              echo ""
              echo "6. **QUALITY STANDARDS**:"
              echo "   - Ensure updates are accurate and clear"
              echo "   - Maintain consistent formatting and style"
              echo "   - Improve documentation quality based on the instruction"
              echo ""
              echo "7. **CONCISENESS â€” THIS IS CRITICAL**:"
              echo "   - Add ONLY the most important, user-facing information"
              echo "   - One or two bullet points per feature/change is sufficient"
              echo "   - NEVER add verbose explanations, background context, or implementation details"
              echo "   - Do NOT rewrite, expand, or rephrase existing content"
              echo "   - If a change can be described in one line, use one line"
              echo "   - Omit anything a developer could infer from the code itself"
              echo ""
              echo "## Response:"
              echo "Output the COMPLETE updated documentation with the user instruction applied."
              echo ""
              echo "Begin your response now:"
            } > "$PROMPT_FILE"
          else
            {
              echo "You are a technical documentation expert tasked with updating documentation based on code changes in a PR."
              echo ""
              echo "## IMPORTANT: PROJECT IDENTITY"
              echo "This documentation is for: $PROJECT_TITLE"
              echo "Repository: $REPO_NAME"
              echo ""
              echo "**CRITICAL**: You MUST maintain the project identity. This is NOT a different project. Do NOT replace this documentation with content about any other project, library, or tool."
              echo ""
              echo "**ROOT-LEVEL DOCS**: These are the root-level documentation files for the entire repository. They should contain only high-level, project-wide information that matters to users and contributors â€” NOT granular implementation details of individual files, functions, or internal logic."
              echo ""
              echo "## Context"
              echo "PR #$PR_NUMBER: $PR_TITLE_CLEAN"
              echo ""
              echo "## User Instruction:"
              echo "A user has requested documentation analysis with the following instruction:"
              echo '```'
              echo "$USER_SUGGESTION_CLEAN"
              echo '```'
              echo ""
              echo "## Current Documentation Content:"
              echo '```'
              echo "$DOC_CONTENT"
              echo '```'
              echo ""
              echo "## PR Changes (Code Diff):"
              echo '```diff'
              echo "$PR_DIFF"
              echo '```'
              echo ""
              echo "## Repository Structure:"
              echo '```'
              echo "$REPO_STRUCTURE"
              echo '```'
              echo ""
              echo "## Format Requirements:"
              echo "$FORMAT_INSTRUCTION"
              echo ""
              echo "## Additional Context:"
              echo "$OTHER_FILES_NOTE"
              echo ""
              echo "## Your Task"
              echo "Analyze the PR changes and the user instruction, then determine if the $DOC_FILE needs updates."
              echo ""
              echo "## ABSOLUTE REQUIREMENTS - VIOLATION WILL BE REJECTED:"
              echo ""
              echo "1. **PRESERVE PROJECT IDENTITY**:"
              echo "   - The project name \"$PROJECT_TITLE\" MUST remain unchanged"
              echo "   - Do NOT replace this with documentation for a different project"
              echo "   - Maintain all existing project-specific information"
              echo ""
              echo "2. **ONLY ADD, NEVER REMOVE**:"
              echo "   - You may ONLY add new information based on PR changes"
              echo "   - NEVER remove existing sections, features, or content"
              echo "   - NEVER replace existing content with unrelated information"
              echo "   - Keep all existing headings, sections, and structure intact"
              echo ""
              echo "3. **STAY RELEVANT TO PR CHANGES**:"
              echo "   - Only update sections directly related to the code changes in the PR diff"
              echo "   - Consider the user instruction as guidance for what to focus on"
              echo "   - If the PR adds a feature, document that feature"
              echo "   - If the PR changes behavior, update that specific behavior section"
              echo "   - Do NOT make unrelated changes"
              echo ""
              echo "4. **VERIFY PROJECT MATCH**:"
              echo "   - Cross-reference the PR diff with the current documentation"
              echo "   - Ensure the technologies, frameworks, and tools mentioned in the PR match those in the documentation"
              echo "   - If there is a mismatch, output NO_UPDATES_NEEDED"
              echo ""
              echo "5. **OUTPUT FORMAT**:"
              echo "   - Output ONLY the complete updated documentation content"
              echo "   - NO preambles, acknowledgments, or explanatory text"
              echo '   - NO phrases like "Here is the updated", "I have analyzed", etc.'
              echo "   - Start directly with the documentation content"
              echo ""
              echo "6. **SIGNIFICANCE CHECK â€” THINK LIKE A SOFTWARE ARCHITECT**:"
              echo "   - Evaluate each change from the perspective of a software architect deciding what belongs in root-level project documentation"
              echo "   - UPDATE for changes that alter the project's public surface: new features, breaking changes, new modules, API changes, new dependencies, major configuration changes"
              echo "   - SKIP changes that are internal to the codebase: refactors, minor bug fixes, test additions, code comments, whitespace, file reorganization, CI/CD pipeline tweaks, implementation details"
              echo "   - When in doubt, assess whether a user or new contributor NEEDS this information at the project level â€” if not, do not update"
              echo "   - Output NO_UPDATES_NEEDED unless the changes genuinely warrant documentation at the root level"
              echo ""
              echo "7. **CONCISENESS â€” THIS IS CRITICAL**:"
              echo "   - Add ONLY the most important, user-facing information"
              echo "   - One or two bullet points per feature/change is sufficient"
              echo "   - NEVER add verbose explanations, background context, or implementation details"
              echo "   - Do NOT rewrite, expand, or rephrase existing content"
              echo "   - If a change can be described in one line, use one line"
              echo "   - Omit anything a developer could infer from the code itself"
              echo ""
              echo "## Decision Process:"
              echo ""
              echo "1. Verify this PR is for the project \"$PROJECT_TITLE\" in repository \"$REPO_NAME\""
              echo "2. Carefully analyze what changed in the PR diff"
              echo "3. Check if ANY new files, modules, functions, or features were added"
              echo "4. Look for changes to existing functionality that users should know about"
              echo "5. Consider the user instruction for guidance on what to focus on"
              echo "6. If ANY of the above exist: Add new information to relevant sections WITHOUT removing existing content"
              echo '7. Output "NO_UPDATES_NEEDED" if no changes warrant root-level documentation updates, applying the architectural judgment from the significance check above'
              echo ""
              echo "## Response:"
              echo "- If significant, relevant updates are needed: Output the COMPLETE updated documentation (with additions only)"
              echo "- If no updates needed OR project mismatch detected: Output exactly: NO_UPDATES_NEEDED"
              echo ""
              echo "Begin your response now:"
            } > "$PROMPT_FILE"
          fi

          chmod 600 "$PROMPT_FILE"

          echo "  Calling Claude API for $DOC_FILE..." >> $GITHUB_STEP_SUMMARY

          REQUEST_FILE="$TEMP_DIR/request_$(openssl rand -hex 8).json"
          jq -n \
            --arg model "claude-sonnet-4-5" \
            --argjson max_tokens 16384 \
            --rawfile content "$PROMPT_FILE" \
            '{
              model: $model,
              max_tokens: $max_tokens,
              messages: [{
                role: "user",
                content: $content
              }]
            }' > "$REQUEST_FILE"

          chmod 600 "$REQUEST_FILE"

          RESPONSE=$(curl -s https://api.anthropic.com/v1/messages \
            -H "content-type: application/json" \
            -H "x-api-key: $ANTHROPIC_API_KEY" \
            -H "anthropic-version: 2023-06-01" \
            -d @"$REQUEST_FILE")

          rm -f "$REQUEST_FILE"

          if ! echo "$RESPONSE" | jq empty 2>/dev/null; then
            echo "  Invalid JSON response from API" >> $GITHUB_STEP_SUMMARY
            return 1
          fi

          if echo "$RESPONSE" | jq -e '.error' > /dev/null 2>&1; then
            ERROR_TYPE=$(echo "$RESPONSE" | jq -r '.error.type // "unknown"')
            ERROR_CODE=$(echo "$RESPONSE" | jq -r '.error.code // "unknown"')
            echo "  Claude API Error for $DOC_FILE: type=$ERROR_TYPE, code=$ERROR_CODE" >> $GITHUB_STEP_SUMMARY
            return 1
          fi

          if ! echo "$RESPONSE" | jq -e '.content[0].text' > /dev/null 2>&1; then
            echo "  API response missing expected content field" >> $GITHUB_STEP_SUMMARY
            return 1
          fi

          CLAUDE_OUTPUT=$(echo "$RESPONSE" | jq -r '.content[0].text')
          CLAUDE_OUTPUT=$(echo "$CLAUDE_OUTPUT" | tr -d '\000' | iconv -c -t UTF-8//IGNORE)

          if [ "$IS_DOCSYNC_PR" != "true" ]; then
            if echo "$CLAUDE_OUTPUT" | grep -q "NO_UPDATES_NEEDED"; then
              echo "  No updates needed for $DOC_FILE" >> $GITHUB_STEP_SUMMARY
              return 0
            fi
          fi

          INPUT_LENGTH=${#DOC_CONTENT}
          OUTPUT_LENGTH=${#CLAUDE_OUTPUT}
          echo "  Updating $DOC_FILE ($INPUT_LENGTH -> $OUTPUT_LENGTH chars)" >> $GITHUB_STEP_SUMMARY

          echo "$CLAUDE_OUTPUT" > "$DOC_FILE"
          ANY_UPDATES=true
          return 0
        }

        # === PHASE 2: UPDATE DOCUMENTATION FILES ===
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "### Updating Documentation Files:" >> $GITHUB_STEP_SUMMARY

        if [ "$HAS_README" = true ] && [ "$HAS_CLAUDE" = true ]; then
          echo "Both $README_FILE and $CLAUDE_FILE detected - updating both" >> $GITHUB_STEP_SUMMARY
          update_doc_file "$README_FILE" "README" "$CLAUDE_FILE also exists in this repository and is being updated separately for AI/Claude Code context. Focus this $README_FILE update on user-facing documentation only." || echo "  Failed to update $README_FILE" >> $GITHUB_STEP_SUMMARY
          update_doc_file "$CLAUDE_FILE" "CLAUDE" "$README_FILE also exists in this repository and is being updated separately for user-facing documentation. Focus this $CLAUDE_FILE update on AI/Claude Code technical context only." || echo "  Failed to update $CLAUDE_FILE" >> $GITHUB_STEP_SUMMARY
        elif [ "$HAS_README" = true ]; then
          echo "Only $README_FILE detected - updating $README_FILE" >> $GITHUB_STEP_SUMMARY
          update_doc_file "$README_FILE" "README" "This is the only documentation file in the repository." || echo "  Failed to update $README_FILE" >> $GITHUB_STEP_SUMMARY
        elif [ "$HAS_CLAUDE" = true ]; then
          echo "Only $CLAUDE_FILE detected - updating $CLAUDE_FILE" >> $GITHUB_STEP_SUMMARY
          update_doc_file "$CLAUDE_FILE" "CLAUDE" "This is the only documentation file in the repository." || echo "  Failed to update $CLAUDE_FILE" >> $GITHUB_STEP_SUMMARY
        fi

        if [ "$ANY_UPDATES" = true ]; then
          echo "skip_analysis=false" >> $GITHUB_OUTPUT
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "Documentation files have been updated" >> $GITHUB_STEP_SUMMARY
        else
          echo "skip_analysis=true" >> $GITHUB_OUTPUT
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "No documentation updates were applied" >> $GITHUB_STEP_SUMMARY
        fi

        # Clean up diff temp directory
        if [ -n "$DIFF_TEMP_DIR" ] && [ -d "$DIFF_TEMP_DIR" ]; then
          rm -rf "$DIFF_TEMP_DIR"
        fi

    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    # STEP 8: Commit changes (update)
    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    - name: Commit Changes to PR
      id: commit-changes
      if: >
        steps.claude-analysis.outputs.skip_analysis != 'true' &&
        steps.parse-command.outputs.command != 'revert_last' &&
        steps.parse-command.outputs.command != 'revert_to'
      shell: bash
      env:
        GH_TOKEN: ${{ inputs.github_token }}
        PR_NUMBER: ${{ inputs.pr_number }}
        IS_DOCSYNC_PR: ${{ steps.verify-pr.outputs.is_docsync_pr }}
        COMMAND: ${{ steps.parse-command.outputs.command }}
        TARGET_FILE: ${{ steps.parse-command.outputs.target_file }}
      run: |
        set -e

        git add -A

        if git diff --cached --quiet; then
          echo "updated=false" >> $GITHUB_OUTPUT
          echo "No documentation updates needed" >> $GITHUB_STEP_SUMMARY
        else
          echo "updated=true" >> $GITHUB_OUTPUT
          echo "Documentation updates detected" >> $GITHUB_STEP_SUMMARY

          echo "### Changed Files:" >> $GITHUB_STEP_SUMMARY
          echo '```' >> $GITHUB_STEP_SUMMARY
          git diff --cached --name-only >> $GITHUB_STEP_SUMMARY
          echo '```' >> $GITHUB_STEP_SUMMARY

          # Verify only documentation files changed
          CHANGED=$(git diff --cached --name-only)
          INVALID_FILES=""

          for file in $CHANGED; do
            FILE_LOWER=$(echo "$file" | tr '[:upper:]' '[:lower:]')
            if [[ "$FILE_LOWER" != "readme.md" ]] && [[ "$FILE_LOWER" != "claude.md" ]]; then
              INVALID_FILES="$INVALID_FILES $file"
            fi
          done

          if [ -n "$INVALID_FILES" ]; then
            echo "ERROR: Non-documentation files were modified:$INVALID_FILES" >> $GITHUB_STEP_SUMMARY
            echo "Only README.md and CLAUDE.md (any casing) should be updated." >> $GITHUB_STEP_SUMMARY
            git reset --hard
            echo "updated=false" >> $GITHUB_OUTPUT
            exit 1
          fi

          git config --local user.name "github-actions[bot]"
          git config --local user.email "github-actions[bot]@users.noreply.github.com"

          CONFIGURED_NAME=$(git config --local user.name)
          if [ "$CONFIGURED_NAME" != "github-actions[bot]" ]; then
            echo "Failed to set git user configuration" >> $GITHUB_STEP_SUMMARY
            exit 1
          fi

          if ! [[ "$PR_NUMBER" =~ ^[0-9]+$ ]]; then
            echo "Invalid PR number for commit" >> $GITHUB_STEP_SUMMARY
            exit 1
          fi

          # Build descriptive commit message
          if [ "$TARGET_FILE" = "readme" ]; then
            TARGET_DESC="README.md"
          elif [ "$TARGET_FILE" = "claude" ]; then
            TARGET_DESC="CLAUDE.md"
          else
            TARGET_DESC="documentation"
          fi

          if [ "$IS_DOCSYNC_PR" = "true" ]; then
            COMMIT_MSG="DocSync AI: Apply @docbot instruction to $TARGET_DESC

        Applied documentation updates based on user command.

        Generated by DocSync AI"
          else
            COMMIT_MSG="DocSync AI: Update $TARGET_DESC from @docbot command

        Applied documentation updates based on PR changes and user instruction.

        Generated by DocSync AI"
          fi

          git commit -m "$COMMIT_MSG"
          git push origin HEAD

          CHANGED_FILES=$(git diff HEAD~1 --name-only | head -10 | sed 's/^/- /')

          if [ "$IS_DOCSYNC_PR" = "true" ]; then
            COMMENT_BODY="**DocSync AI â€” Update Applied** :white_check_mark:

        Your documentation instruction has been applied and committed.

        **Updated Files:**
        $CHANGED_FILES

        ---
        *Automated by DocSync AI*"
          else
            COMMENT_BODY="**DocSync AI â€” Documentation Updated** :white_check_mark:

        Documentation has been updated based on the changes in this PR and your instruction.

        **Updated Files:**
        $CHANGED_FILES

        ---
        *Automated by DocSync AI*"
          fi

          gh pr comment "$PR_NUMBER" --body "$COMMENT_BODY"

          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Changes Committed and Comment Added" >> $GITHUB_STEP_SUMMARY
        fi

    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    # STEP 9: Summary
    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    - name: Summary
      if: always()
      shell: bash
      env:
        VALID: ${{ steps.parse-command.outputs.valid }}
        COMMAND: ${{ steps.parse-command.outputs.command }}
        TARGET_FILE: ${{ steps.parse-command.outputs.target_file }}
        IS_DOCSYNC: ${{ steps.verify-pr.outputs.is_docsync_pr }}
        UPDATED_COMMIT: ${{ steps.commit-changes.outputs.updated }}
        UPDATED_REVERT: ${{ steps.revert-changes.outputs.updated }}
      run: |
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "## Action Summary" >> $GITHUB_STEP_SUMMARY
        echo "- **Command Valid**: ${VALID:-false}" >> $GITHUB_STEP_SUMMARY
        echo "- **Command**: ${COMMAND:-none}" >> $GITHUB_STEP_SUMMARY
        echo "- **Target File**: ${TARGET_FILE:-all}" >> $GITHUB_STEP_SUMMARY
        echo "- **Is DocSync PR**: ${IS_DOCSYNC:-false}" >> $GITHUB_STEP_SUMMARY
        echo "- **Documentation Updated**: $([ '$UPDATED_COMMIT' = 'true' ] || [ '$UPDATED_REVERT' = 'true' ] && echo 'true' || echo 'false')" >> $GITHUB_STEP_SUMMARY