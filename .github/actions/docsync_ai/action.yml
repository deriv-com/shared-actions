name: DocSync AI - Documentation Sync
description: Automatically update documentation based on weekly merged PRs using Claude AI

inputs:
  github_token:
    description: "GitHub token for repository operations and PR creation"
    required: true
  anthropic_api_key:
    description: "Anthropic API key for Claude AI"
    required: true
  repository:
    description: "Repository name (owner/repo)"
    required: true
  base_branch:
    description: "Base branch for documentation PR (e.g., master or main)"
    required: false
    default: "master"
  pr_labels:
    description: "Comma-separated labels for the documentation PR"
    required: false
    default: "documentation,automated"

outputs:
  doc_pr_created:
    description: "Whether a documentation PR was created"
    value: ${{ steps.create-doc-pr.outputs.pr_created }}
  doc_pr_number:
    description: "Documentation PR number if created"
    value: ${{ steps.create-doc-pr.outputs.pr_number }}
  doc_pr_url:
    description: "Documentation PR URL if created"
    value: ${{ steps.create-doc-pr.outputs.pr_url }}

runs:
  using: composite
  steps:
    - name: Checkout Repository
      uses: actions/checkout@v4
      with:
        token: ${{ inputs.github_token }}
        ref: ${{ inputs.base_branch }}
        fetch-depth: 0

    - name: Debug - Repository State
      shell: bash
      run: |
        echo "## Repository State" >> $GITHUB_STEP_SUMMARY
        echo "Working directory: $(pwd)" >> $GITHUB_STEP_SUMMARY
        echo "Current branch: $(git branch --show-current)" >> $GITHUB_STEP_SUMMARY
        echo "Latest commit: $(git log -1 --oneline)" >> $GITHUB_STEP_SUMMARY

        # Check for existing documentation files (case-insensitive)
        find . -maxdepth 1 -iname "readme.md" | while read f; do echo "Found ${f#./}" >> $GITHUB_STEP_SUMMARY; done
        find . -maxdepth 1 -iname "claude.md" | while read f; do echo "Found ${f#./}" >> $GITHUB_STEP_SUMMARY; done

    - name: Fetch Weekly Merged PRs
      id: pr-details
      shell: bash
      env:
        GH_TOKEN: ${{ inputs.github_token }}
        REPO_NAME: ${{ inputs.repository }}
        BASE_BRANCH: ${{ inputs.base_branch }}
      run: |
        set -e

        # Validate repository format (owner/repo)
        if ! [[ "$REPO_NAME" =~ ^[a-zA-Z0-9_-]+/[a-zA-Z0-9_.-]+$ ]]; then
          echo "Invalid repository format: $REPO_NAME" >> $GITHUB_STEP_SUMMARY
          exit 1
        fi

        if [ ${#REPO_NAME} -gt 100 ]; then
          echo "Repository name too long" >> $GITHUB_STEP_SUMMARY
          exit 1
        fi

        echo "## Weekly Merged PRs" >> $GITHUB_STEP_SUMMARY
        echo "Repository: $REPO_NAME" >> $GITHUB_STEP_SUMMARY

        # Create secure temporary directory
        TEMP_DIR=$(mktemp -d -t docsync-XXXXXXXXXX)
        echo "temp_dir=$TEMP_DIR" >> $GITHUB_OUTPUT

        # Calculate date 7 days ago (compatible with Ubuntu/GNU date)
        SINCE_DATE=$(date -u -d '7 days ago' +%Y-%m-%dT%H:%M:%SZ 2>/dev/null || date -u -v-7d +%Y-%m-%dT%H:%M:%SZ)
        echo "Looking for PRs merged since: $SINCE_DATE" >> $GITHUB_STEP_SUMMARY

        # Fetch all merged PRs to base branch in the last 7 days
        # Use GitHub Search API to find merged PRs
        MERGED_PRS=$(gh api \
          -H "Accept: application/vnd.github+json" \
          "/repos/$REPO_NAME/pulls?state=closed&base=$BASE_BRANCH&sort=updated&direction=desc&per_page=100" \
          --jq "[.[] | select(.merged_at != null and .merged_at >= \"$SINCE_DATE\")]" 2>&1 || echo "[]")

        # Validate response is valid JSON
        if ! echo "$MERGED_PRS" | jq empty 2>/dev/null; then
          echo "Invalid response from GitHub API" >> $GITHUB_STEP_SUMMARY
          exit 1
        fi

        # Filter out DocSync AI PRs and automated PRs
        FILTERED_PRS=$(echo "$MERGED_PRS" | jq '[.[] | select(
          (.title | test("DocSync AI"; "i") | not) and
          ([.labels[].name] | any(. == "automated") | not)
        )]')

        PR_COUNT=$(echo "$FILTERED_PRS" | jq 'length')
        echo "Found $PR_COUNT merged PR(s) in the last 7 days (excluding DocSync AI PRs)" >> $GITHUB_STEP_SUMMARY

        if [ "$PR_COUNT" -eq 0 ]; then
          echo "No merged PRs found in the last 7 days - skipping documentation update" >> $GITHUB_STEP_SUMMARY
          echo "skip_analysis=true" >> $GITHUB_OUTPUT
          rm -rf "$TEMP_DIR"
          exit 0
        fi

        # Build PR summary and aggregate diffs
        PR_SUMMARY=""
        COMBINED_DIFF=""
        ALL_CHANGED_FILES=""

        # Save PR list for later reference
        echo "$FILTERED_PRS" | jq -r '.[].number' > "$TEMP_DIR/pr_numbers.txt"
        chmod 600 "$TEMP_DIR/pr_numbers.txt"

        echo "### Merged PRs:" >> $GITHUB_STEP_SUMMARY

        while IFS= read -r PR_NUM; do
          # Validate PR number
          if ! [[ "$PR_NUM" =~ ^[0-9]+$ ]]; then
            continue
          fi

          # Get PR metadata
          PR_TITLE=$(echo "$FILTERED_PRS" | jq -r ".[] | select(.number == $PR_NUM) | .title" | tr -d '\000-\037' | head -c 200)
          PR_BODY_RAW=$(echo "$FILTERED_PRS" | jq -r ".[] | select(.number == $PR_NUM) | .body // \"\"" | tr -d '\000' | iconv -c -t UTF-8//IGNORE | head -c 5000)

          echo "- PR #$PR_NUM: $PR_TITLE" >> $GITHUB_STEP_SUMMARY

          PR_SUMMARY="${PR_SUMMARY}
        - PR #${PR_NUM}: ${PR_TITLE}
          Description: ${PR_BODY_RAW}"

          # Get full PR diff (no size limit)
          PR_DIFF=$(gh api \
            -H "Accept: application/vnd.github.v3.diff" \
            "/repos/$REPO_NAME/pulls/$PR_NUM" 2>&1)

          # Sanitize and validate diff content
          PR_DIFF=$(echo "$PR_DIFF" | tr -d '\000' | iconv -c -t UTF-8//IGNORE)

          # Filter out .github/workflows diffs (don't include workflow changes in analysis)
          PR_DIFF=$(echo "$PR_DIFF" | awk '
            BEGIN { skip=0 }
            /^diff --git.*\.github\/workflows\// { skip=1; next }
            /^diff --git/ { skip=0 }
            !skip { print }
          ')

          COMBINED_DIFF="${COMBINED_DIFF}

        === PR #${PR_NUM}: ${PR_TITLE} ===
        ${PR_DIFF}"

          # Get list of changed files for this PR
          CHANGED_FILES=$(gh api \
            -H "Accept: application/vnd.github+json" \
            "/repos/$REPO_NAME/pulls/$PR_NUM/files" \
            --jq '.[].filename' 2>&1 || echo "")

          # Filter out .github/workflows files
          CHANGED_FILES_FILTERED=$(echo "$CHANGED_FILES" | grep -v '^\.github/workflows/' || echo "")
          ALL_CHANGED_FILES="${ALL_CHANGED_FILES}
        ${CHANGED_FILES_FILTERED}"

        done < "$TEMP_DIR/pr_numbers.txt"

        # Validate inputs for suspicious patterns
        if echo "$PR_SUMMARY" | grep -qE '\$\(|\`|;[[:space:]]*curl|;[[:space:]]*wget|eval|exec'; then
          echo "Warning: Suspicious pattern detected in PR inputs" >> $GITHUB_STEP_SUMMARY
          # Continue but log the warning
        fi

        # Deduplicate changed files
        ALL_CHANGED_FILES=$(echo "$ALL_CHANGED_FILES" | sort -u | grep -v '^$' || echo "")

        # Check if all changes were in workflows only
        if [ -z "$ALL_CHANGED_FILES" ] && [ -n "$COMBINED_DIFF" ]; then
          # All filtered PRs only had workflow changes
          NON_WORKFLOW_DIFF=$(echo "$COMBINED_DIFF" | grep -v '=== PR #' | grep -v '^$' || echo "")
          if [ -z "$NON_WORKFLOW_DIFF" ]; then
            echo "All changes are in .github/workflows - skipping documentation update" >> $GITHUB_STEP_SUMMARY
            echo "skip_analysis=true" >> $GITHUB_OUTPUT
            exit 0
          fi
        fi

        # Save combined diff to secure temp file
        echo "$COMBINED_DIFF" > "$TEMP_DIR/pr_diff.txt"
        chmod 600 "$TEMP_DIR/pr_diff.txt"

        # Save PR summary to secure temp file
        echo "$PR_SUMMARY" > "$TEMP_DIR/pr_summary.txt"
        chmod 600 "$TEMP_DIR/pr_summary.txt"

        # Save PR count for later
        echo "pr_count=$PR_COUNT" >> $GITHUB_OUTPUT

        # Sanitize changed files list (truncate for summary)
        CHANGED_FILES_SUMMARY=$(echo "$ALL_CHANGED_FILES" | head -n 50)

        echo "### Changed Files (excluding workflows):" >> $GITHUB_STEP_SUMMARY
        echo '```' >> $GITHUB_STEP_SUMMARY
        echo "$CHANGED_FILES_SUMMARY" >> $GITHUB_STEP_SUMMARY
        echo '```' >> $GITHUB_STEP_SUMMARY

        echo "changed_files<<EOF" >> $GITHUB_OUTPUT
        echo "$ALL_CHANGED_FILES" >> $GITHUB_OUTPUT
        echo "EOF" >> $GITHUB_OUTPUT

    - name: Run Claude Sonnet 4.5 Documentation Analysis
      id: claude-analysis
      if: steps.pr-details.outputs.skip_analysis != 'true'
      shell: bash
      env:
        ANTHROPIC_API_KEY: ${{ inputs.anthropic_api_key }}
        REPO_NAME: ${{ inputs.repository }}
        BASE_BRANCH: ${{ inputs.base_branch }}
        TEMP_DIR: ${{ steps.pr-details.outputs.temp_dir }}
        PR_COUNT: ${{ steps.pr-details.outputs.pr_count }}
        CHANGED_FILES: ${{ steps.pr-details.outputs.changed_files }}
      run: |
        set -e
        trap '[ $? -ne 0 ] && rm -rf "$TEMP_DIR" 2>/dev/null' EXIT

        echo "## Claude Sonnet 4.5 Analysis" >> $GITHUB_STEP_SUMMARY
        echo "Model: claude-sonnet-4-5" >> $GITHUB_STEP_SUMMARY
        echo "Analyzing $PR_COUNT merged PR(s) from the past week" >> $GITHUB_STEP_SUMMARY

        # Read PR summary from secure temp file
        PR_SUMMARY=""
        if [ -f "$TEMP_DIR/pr_summary.txt" ]; then
          PR_SUMMARY=$(cat "$TEMP_DIR/pr_summary.txt")
        fi

        # Sanitize PR summary
        PR_SUMMARY_CLEAN=$(echo "$PR_SUMMARY" | tr -d '\000' | iconv -c -t UTF-8//IGNORE)

        # === PHASE 1: DETECT ALL DOCUMENTATION FILES ===
        # Check for BOTH files before updating anything
        HAS_README=false
        HAS_CLAUDE=false

        # Validate file paths helper function
        validate_doc_file() {
          local file=$1
          # Must be in current directory, not a symlink, and match expected names
          if [[ ! -f "$file" ]] || [[ -L "$file" ]]; then
            return 1
          fi
          local basename=$(basename "$file")
          local basename_lower=$(echo "$basename" | tr '[:upper:]' '[:lower:]')
          if [[ "$basename_lower" != "readme.md" ]] && [[ "$basename_lower" != "claude.md" ]]; then
            return 1
          fi
          # Ensure file is in repo root (no directory traversal)
          local realpath=$(realpath "$file" 2>/dev/null || echo "")
          local workdir=$(realpath . 2>/dev/null || echo "")
          if [[ ! "$realpath" == "$workdir"/* ]]; then
            return 1
          fi
          return 0
        }

        # Case-insensitive check for README.md
        README_FILE=$(find . -maxdepth 1 -type f -iname "readme.md" -print -quit 2>/dev/null)
        if [ -n "$README_FILE" ]; then
          README_FILE="${README_FILE#./}"
          if validate_doc_file "$README_FILE"; then
            HAS_README=true
          else
            echo "Invalid README file detected, skipping" >> $GITHUB_STEP_SUMMARY
            README_FILE=""
          fi
        fi

        # Case-insensitive check for CLAUDE.md
        CLAUDE_FILE=$(find . -maxdepth 1 -type f -iname "claude.md" -print -quit 2>/dev/null)
        if [ -n "$CLAUDE_FILE" ]; then
          CLAUDE_FILE="${CLAUDE_FILE#./}"
          if validate_doc_file "$CLAUDE_FILE"; then
            HAS_CLAUDE=true
          else
            echo "Invalid CLAUDE file detected, skipping" >> $GITHUB_STEP_SUMMARY
            CLAUDE_FILE=""
          fi
        fi

        # Log detection results for both files
        echo "### Documentation File Detection:" >> $GITHUB_STEP_SUMMARY
        echo "- README.md: $([ "$HAS_README" = true ] && echo "Found ($README_FILE)" || echo 'Not found')" >> $GITHUB_STEP_SUMMARY
        echo "- CLAUDE.md: $([ "$HAS_CLAUDE" = true ] && echo "Found ($CLAUDE_FILE)" || echo 'Not found')" >> $GITHUB_STEP_SUMMARY

        if [ "$HAS_README" = false ] && [ "$HAS_CLAUDE" = false ]; then
          echo "No documentation file found (README.md or CLAUDE.md)" >> $GITHUB_STEP_SUMMARY
          echo "skip_analysis=true" >> $GITHUB_OUTPUT
          rm -rf "$TEMP_DIR"
          exit 0
        fi

        # Read combined PR diff from secure temp file
        PR_DIFF_FILE="$TEMP_DIR/pr_diff.txt"
        if [ -f "$PR_DIFF_FILE" ]; then
          PR_DIFF=$(cat "$PR_DIFF_FILE")
        else
          PR_DIFF="No diff available"
        fi

        # === DIFF SIZE MANAGEMENT ===
        # If the combined diff exceeds Claude's context window, chunk and summarize
        MAX_DIFF_CHARS=600000
        CHUNK_MAX_CHARS=500000
        DIFF_SIZE=${#PR_DIFF}

        if [ "$DIFF_SIZE" -gt "$MAX_DIFF_CHARS" ]; then
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Large Diff Detected" >> $GITHUB_STEP_SUMMARY
          echo "Combined diff is $DIFF_SIZE chars (limit: $MAX_DIFF_CHARS). Chunking and summarizing..." >> $GITHUB_STEP_SUMMARY

          CHUNK_DIR="$TEMP_DIR/diff_chunks"
          rm -rf "$CHUNK_DIR"
          mkdir -p "$CHUNK_DIR"

          # Split diff into chunks at "diff --git" boundaries, each â‰¤ CHUNK_MAX_CHARS
          awk -v max="$CHUNK_MAX_CHARS" -v dir="$CHUNK_DIR" '
            BEGIN { chunk=1; size=0; file=dir "/chunk_1.txt" }
            /^diff --git / {
              if (size > max && size > 0) {
                close(file)
                chunk++
                size=0
                file=dir "/chunk_" chunk ".txt"
              }
            }
            { print >> file; size += length($0) + 1 }
            END { close(file); print chunk > dir "/chunk_count.txt" }
          ' "$TEMP_DIR/pr_diff.txt"

          TOTAL_CHUNKS=$(cat "$CHUNK_DIR/chunk_count.txt" 2>/dev/null || echo "1")
          echo "Split into $TOTAL_CHUNKS chunk(s)" >> $GITHUB_STEP_SUMMARY

          ALL_SUMMARIES=""
          for i in $(seq 1 "$TOTAL_CHUNKS"); do
            CHUNK_PATH="$CHUNK_DIR/chunk_${i}.txt"
            [ -f "$CHUNK_PATH" ] || continue
            CHUNK_BYTES=$(wc -c < "$CHUNK_PATH" | tr -d ' ')
            echo "  Summarizing chunk $i/$TOTAL_CHUNKS (~$CHUNK_BYTES chars)..." >> $GITHUB_STEP_SUMMARY

            # Build summarization prompt
            SPROMPT_FILE="$TEMP_DIR/sprompt_${i}.txt"
            {
              echo "You are analyzing code changes to identify documentation-relevant updates for root-level project documentation (README.md / CLAUDE.md)."
              echo ""
              echo "Repository: $REPO_NAME"
              echo ""
              echo "Review the code diff below and extract ONLY changes that would affect root-level project documentation:"
              echo "- New features, modules, or public APIs"
              echo "- Breaking changes or changed behavior"
              echo "- New dependencies"
              echo "- Major configuration changes"
              echo "- Changes to project setup, installation, or usage"
              echo ""
              echo "For each doc-relevant change found, provide:"
              echo "1. A concise description of what changed"
              echo "2. The files involved"
              echo "3. Why it matters for root-level documentation"
              echo ""
              echo "If nothing in this diff chunk is relevant to root-level documentation, output exactly: NO_DOC_RELEVANT_CHANGES"
              echo ""
              echo "Code diff (chunk $i of $TOTAL_CHUNKS):"
              echo '```diff'
              cat "$CHUNK_PATH"
              echo '```'
            } > "$SPROMPT_FILE"
            chmod 600 "$SPROMPT_FILE"

            # Build API request
            SREQUEST_FILE="$TEMP_DIR/srequest_${i}.json"
            jq -n \
              --arg model "claude-sonnet-4-5" \
              --argjson max_tokens 4096 \
              --rawfile content "$SPROMPT_FILE" \
              '{
                model: $model,
                max_tokens: $max_tokens,
                messages: [{
                  role: "user",
                  content: $content
                }]
              }' > "$SREQUEST_FILE"
            chmod 600 "$SREQUEST_FILE"

            # Call Claude API for chunk summarization
            SRESPONSE=$(curl -s https://api.anthropic.com/v1/messages \
              -H "content-type: application/json" \
              -H "x-api-key: $ANTHROPIC_API_KEY" \
              -H "anthropic-version: 2023-06-01" \
              -d @"$SREQUEST_FILE")

            rm -f "$SREQUEST_FILE" "$SPROMPT_FILE"

            # Validate response
            if ! echo "$SRESPONSE" | jq empty 2>/dev/null; then
              echo "  Warning: Invalid response for chunk $i" >> $GITHUB_STEP_SUMMARY
              continue
            fi

            if echo "$SRESPONSE" | jq -e '.error' > /dev/null 2>&1; then
              SERR_TYPE=$(echo "$SRESPONSE" | jq -r '.error.type // "unknown"')
              echo "  Warning: API error for chunk $i: $SERR_TYPE" >> $GITHUB_STEP_SUMMARY
              continue
            fi

            CHUNK_SUMMARY=$(echo "$SRESPONSE" | jq -r '.content[0].text // ""' | tr -d '\000' | iconv -c -t UTF-8//IGNORE)

            if [ -n "$CHUNK_SUMMARY" ] && ! echo "$CHUNK_SUMMARY" | grep -q "NO_DOC_RELEVANT_CHANGES"; then
              ALL_SUMMARIES="${ALL_SUMMARIES}

              --- Chunk $i Analysis ---
              ${CHUNK_SUMMARY}"
              echo "  Chunk $i: doc-relevant changes found" >> $GITHUB_STEP_SUMMARY
            else
              echo "  Chunk $i: no doc-relevant changes" >> $GITHUB_STEP_SUMMARY
            fi
          done

          rm -rf "$CHUNK_DIR"

          # Replace PR_DIFF with summaries for the update prompt
          if [ -n "$ALL_SUMMARIES" ]; then
            PR_DIFF="[SUMMARIZED â€” Original diff was ${DIFF_SIZE} chars. Each chunk was analyzed by Claude Sonnet 4.5 for documentation-relevant changes.]
            ${ALL_SUMMARIES}"
            echo "Diff chunking complete â€” summaries ready for update prompt" >> $GITHUB_STEP_SUMMARY
          else
            PR_DIFF="[ANALYZED â€” Original diff was ${DIFF_SIZE} chars across $TOTAL_CHUNKS chunks. No documentation-relevant changes were identified in any chunk.]"
            echo "No doc-relevant changes found in any chunk" >> $GITHUB_STEP_SUMMARY
          fi
        else
          echo "Diff size: $DIFF_SIZE chars (within context limits)" >> $GITHUB_STEP_SUMMARY
        fi

        # Get repository structure (more restrictive search)
        REPO_STRUCTURE=$(find . -maxdepth 3 -type f \
          \( -name "*.js" -o -name "*.ts" -o -name "*.jsx" -o -name "*.tsx" -o -name "*.py" -o -name "*.go" -o -name "*.java" -o -name "*.yml" -o -name "*.yaml" \) \
          -not -path "*/node_modules/*" \
          -not -path "*/.git/*" \
          -not -path "*/vendor/*" \
          -not -path "*/dist/*" \
          -not -path "*/build/*" \
          -not -name "*secret*" \
          -not -name "*credential*" \
          -not -name "*.env*" \
          2>/dev/null | head -30 | sed 's|^\./||' || echo "")

        ANY_UPDATES=false

        # Function to call Claude API for documentation update
        update_doc_file() {
          local DOC_FILE=$1
          local DOC_FORMAT=$2
          local OTHER_FILES_NOTE=$3

          echo "Processing $DOC_FILE..." >> $GITHUB_STEP_SUMMARY

          # Validate doc file path
          if ! validate_doc_file "$DOC_FILE"; then
            echo "  Invalid doc file: $DOC_FILE" >> $GITHUB_STEP_SUMMARY
            return 1
          fi

          # Read current documentation
          DOC_CONTENT=$(cat "$DOC_FILE")

          # Extract project title/name for validation (from first heading)
          PROJECT_TITLE=$(echo "$DOC_CONTENT" | head -n 30 | grep -E "^#\s+" | head -n 1 | sed 's/^#*\s*//' | tr -d '\000-\037' | head -c 200)
          if [ -z "$PROJECT_TITLE" ]; then
            PROJECT_TITLE="Unknown Project"
          fi

          # Extract key terms from existing documentation for validation
          KEY_TERMS=$(echo "$DOC_CONTENT" | head -n 100 | grep -oE '\b[A-Z][A-Za-z0-9]{3,}\b' | sort -u | head -n 20 | tr '\n' ',' | sed 's/,$//')

          echo "  Project: $PROJECT_TITLE" >> $GITHUB_STEP_SUMMARY

          # Prepare the prompt based on file type
          if [ "$DOC_FORMAT" = "README" ]; then
            FORMAT_INSTRUCTION="This is a README.md file. Maintain standard README format with clear sections, proper markdown formatting, badges, installation instructions, usage examples, and project overview. Keep the professional, user-facing documentation style."
          else
            FORMAT_INSTRUCTION="This is a CLAUDE.md file for AI assistance. Maintain the technical, detailed format suitable for AI context with implementation details, architecture notes, and development guidelines. Keep the detailed, technical documentation style."
          fi

          # Create secure prompt file using echo for proper variable expansion
          # NOTE: heredoc with 'EOF' (quoted) does NOT expand variables - use echo instead
          PROMPT_FILE="$TEMP_DIR/claude_prompt_$(openssl rand -hex 8).txt"
          {
            echo "You are a technical documentation expert tasked with updating documentation based on recent code changes from the past week."
            echo ""
            echo "## IMPORTANT: PROJECT IDENTITY"
            echo "This documentation is for: $PROJECT_TITLE"
            echo "Repository: $REPO_NAME"
            echo ""
            echo "**CRITICAL**: You MUST maintain the project identity. This is NOT a different project. Do NOT replace this documentation with content about any other project, library, or tool."
            echo ""
            echo "**ROOT-LEVEL DOCS**: These are the root-level documentation files for the entire repository. They should contain only high-level, project-wide information that matters to users and contributors â€” NOT granular implementation details of individual files, functions, or internal logic."
            echo ""
            echo "## Context - Weekly PR Summary"
            echo "The following PRs were merged to $BASE_BRANCH in the past week:"
            echo "$PR_SUMMARY_CLEAN"
            echo ""
            echo "## Current Documentation Content:"
            echo '```'
            echo "$DOC_CONTENT"
            echo '```'
            echo ""
            echo "## Combined PR Changes (Code Diffs from the past week):"
            echo '```diff'
            echo "$PR_DIFF"
            echo '```'
            echo ""
            echo "## Repository Structure:"
            echo '```'
            echo "$REPO_STRUCTURE"
            echo '```'
            echo ""
            echo "## ALL Changed Files Across Merged PRs (excluding workflow files):"
            echo "These are ALL the files that were added, modified, or deleted across ALL merged PRs this week."
            echo "Pay special attention to NEW files - these likely represent new features or modules that MUST be documented."
            echo '```'
            echo "$CHANGED_FILES"
            echo '```'
            echo ""
            echo "## Format Requirements:"
            echo "$FORMAT_INSTRUCTION"
            echo ""
            echo "## Additional Context:"
            echo "$OTHER_FILES_NOTE"
            echo ""
            echo "## Your Task"
            echo "Analyze ALL the merged PR changes from the past week and determine if the $DOC_FILE needs updates."
            echo ""
            echo "## ABSOLUTE REQUIREMENTS - VIOLATION WILL BE REJECTED:"
            echo ""
            echo "1. **PRESERVE PROJECT IDENTITY**:"
            echo "   - The project name \"$PROJECT_TITLE\" MUST remain unchanged"
            echo "   - Do NOT replace this with documentation for a different project"
            echo "   - Maintain all existing project-specific information"
            echo ""
            echo "2. **ONLY ADD, NEVER REMOVE**:"
            echo "   - You may ONLY add new information based on PR changes"
            echo "   - NEVER remove existing sections, features, or content"
            echo "   - NEVER replace existing content with unrelated information"
            echo "   - Keep all existing headings, sections, and structure intact"
            echo ""
            echo "3. **STAY RELEVANT TO PR CHANGES**:"
            echo "   - Only update sections directly related to the code changes in the PR diffs"
            echo "   - If PRs add features, document those features"
            echo "   - If PRs change behavior, update those specific behavior sections"
            echo "   - Do NOT make unrelated changes"
            echo ""
            echo "4. **VERIFY PROJECT MATCH**:"
            echo "   - Cross-reference the PR diffs with the current documentation"
            echo "   - Ensure the technologies, frameworks, and tools mentioned in the PRs match those in the documentation"
            echo "   - If there is a mismatch, output NO_UPDATES_NEEDED"
            echo ""
            echo "5. **OUTPUT FORMAT**:"
            echo "   - Output ONLY the complete updated documentation content"
            echo "   - NO preambles, acknowledgments, or explanatory text"
            echo '   - NO phrases like "Here is the updated", "I have analyzed", etc.'
            echo "   - Start directly with the documentation content"
            echo ""
            echo "6. **SIGNIFICANCE CHECK â€” THINK LIKE A SOFTWARE ARCHITECT**:"
            echo "   - Evaluate each change from the perspective of a software architect deciding what belongs in root-level project documentation"
            echo "   - UPDATE for changes that alter the project's public surface: new features, breaking changes, new modules, API changes, new dependencies, major configuration changes"
            echo "   - SKIP changes that are internal to the codebase: refactors, minor bug fixes, test additions, code comments, whitespace, file reorganization, CI/CD pipeline tweaks, implementation details"
            echo "   - When in doubt, assess whether a user or new contributor NEEDS this information at the project level â€” if not, do not update"
            echo "   - Output NO_UPDATES_NEEDED unless the changes genuinely warrant documentation at the root level"
            echo ""
            echo "7. **CONCISENESS â€” THIS IS CRITICAL**:"
            echo "   - Add ONLY the most important, user-facing information"
            echo "   - One or two bullet points per feature/change is sufficient"
            echo "   - NEVER add verbose explanations, background context, or implementation details"
            echo "   - Do NOT rewrite, expand, or rephrase existing content"
            echo "   - If a change can be described in one line, use one line"
            echo "   - Omit anything a developer could infer from the code itself"
            echo ""
            echo "## Decision Process:"
            echo ""
            echo "1. Verify these PRs are for the project \"$PROJECT_TITLE\" in repository \"$REPO_NAME\""
            echo "2. Carefully analyze what changed across ALL merged PRs in the diffs"
            echo "3. Check if ANY new files, modules, functions, or features were added"
            echo "4. Look for changes to existing functionality that users should know about"
            echo "5. If ANY of the above exist: Add new information to relevant sections WITHOUT removing existing content"
            echo '6. Output "NO_UPDATES_NEEDED" if no changes warrant root-level documentation updates, applying the architectural judgment from the significance check above'
            echo ""
            echo "## Response:"
            echo "- If significant, relevant updates are needed: Output the COMPLETE updated documentation (with additions only)"
            echo "- If no updates needed OR project mismatch detected: Output exactly: NO_UPDATES_NEEDED"
            echo ""
            echo "Begin your response now:"
          } > "$PROMPT_FILE"

          chmod 600 "$PROMPT_FILE"

          # Call Claude API with secure header handling
          echo "  Calling Claude API for $DOC_FILE..." >> $GITHUB_STEP_SUMMARY

          # Create secure request body file using jq --rawfile for safe prompt handling
          REQUEST_FILE="$TEMP_DIR/request_$(openssl rand -hex 8).json"
          jq -n \
            --arg model "claude-sonnet-4-5" \
            --argjson max_tokens 16384 \
            --rawfile content "$PROMPT_FILE" \
            '{
              model: $model,
              max_tokens: $max_tokens,
              messages: [{
                role: "user",
                content: $content
              }]
            }' > "$REQUEST_FILE"

          chmod 600 "$REQUEST_FILE"

          # Call API
          RESPONSE=$(curl -s https://api.anthropic.com/v1/messages \
            -H "content-type: application/json" \
            -H "x-api-key: $ANTHROPIC_API_KEY" \
            -H "anthropic-version: 2023-06-01" \
            -d @"$REQUEST_FILE")

          # Clean up request file
          rm -f "$REQUEST_FILE"

          # Validate response is valid JSON
          if ! echo "$RESPONSE" | jq empty 2>/dev/null; then
            echo "  Invalid JSON response from API" >> $GITHUB_STEP_SUMMARY
            return 1
          fi

          # Check for API errors
          if echo "$RESPONSE" | jq -e '.error' > /dev/null 2>&1; then
            ERROR_TYPE=$(echo "$RESPONSE" | jq -r '.error.type // "unknown"')
            ERROR_CODE=$(echo "$RESPONSE" | jq -r '.error.code // "unknown"')
            echo "  Claude API Error for $DOC_FILE: type=$ERROR_TYPE, code=$ERROR_CODE" >> $GITHUB_STEP_SUMMARY
            return 1
          fi

          # Validate response structure
          if ! echo "$RESPONSE" | jq -e '.content[0].text' > /dev/null 2>&1; then
            echo "  API response missing expected content field" >> $GITHUB_STEP_SUMMARY
            return 1
          fi

          # Extract the response content
          CLAUDE_OUTPUT=$(echo "$RESPONSE" | jq -r '.content[0].text')

          # Sanitize output (remove null bytes, validate UTF-8)
          CLAUDE_OUTPUT=$(echo "$CLAUDE_OUTPUT" | tr -d '\000' | iconv -c -t UTF-8//IGNORE)

          # Check if updates are needed
          if echo "$CLAUDE_OUTPUT" | grep -q "NO_UPDATES_NEEDED"; then
            echo "  No updates needed for $DOC_FILE" >> $GITHUB_STEP_SUMMARY
            return 0
          fi

          # Log output stats
          INPUT_LENGTH=${#DOC_CONTENT}
          OUTPUT_LENGTH=${#CLAUDE_OUTPUT}
          echo "  Updating $DOC_FILE ($INPUT_LENGTH -> $OUTPUT_LENGTH chars)" >> $GITHUB_STEP_SUMMARY

          # Write the updated documentation
          echo "$CLAUDE_OUTPUT" > "$DOC_FILE"
          ANY_UPDATES=true
          return 0
        }

        # === PHASE 2: UPDATE ALL DETECTED DOCUMENTATION FILES ===
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "### Updating Documentation Files:" >> $GITHUB_STEP_SUMMARY

        if [ "$HAS_README" = true ] && [ "$HAS_CLAUDE" = true ]; then
          echo "Both $README_FILE and $CLAUDE_FILE detected - updating both" >> $GITHUB_STEP_SUMMARY
          update_doc_file "$README_FILE" "README" "$CLAUDE_FILE also exists in this repository and is being updated separately for AI/Claude Code context. Focus this $README_FILE update on user-facing documentation only." || echo "  Failed to update $README_FILE" >> $GITHUB_STEP_SUMMARY
          update_doc_file "$CLAUDE_FILE" "CLAUDE" "$README_FILE also exists in this repository and is being updated separately for user-facing documentation. Focus this $CLAUDE_FILE update on AI/Claude Code technical context only." || echo "  Failed to update $CLAUDE_FILE" >> $GITHUB_STEP_SUMMARY
        elif [ "$HAS_README" = true ]; then
          echo "Only $README_FILE detected - updating $README_FILE" >> $GITHUB_STEP_SUMMARY
          update_doc_file "$README_FILE" "README" "This is the only documentation file in the repository." || echo "  Failed to update $README_FILE" >> $GITHUB_STEP_SUMMARY
        elif [ "$HAS_CLAUDE" = true ]; then
          echo "Only $CLAUDE_FILE detected - updating $CLAUDE_FILE" >> $GITHUB_STEP_SUMMARY
          update_doc_file "$CLAUDE_FILE" "CLAUDE" "This is the only documentation file in the repository." || echo "  Failed to update $CLAUDE_FILE" >> $GITHUB_STEP_SUMMARY
        fi

        # Set final output
        if [ "$ANY_UPDATES" = true ]; then
          echo "skip_analysis=false" >> $GITHUB_OUTPUT
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "Documentation files have been updated" >> $GITHUB_STEP_SUMMARY
        else
          echo "skip_analysis=true" >> $GITHUB_OUTPUT
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "No documentation updates needed" >> $GITHUB_STEP_SUMMARY
        fi

        # Note: TEMP_DIR cleanup deferred â€” PR creation step still needs pr_numbers.txt

    - name: Check for Documentation Changes
      id: check-changes
      if: steps.claude-analysis.outputs.skip_analysis != 'true'
      shell: bash
      run: |
        # Check if documentation files were modified
        git add -A

        if git diff --cached --quiet; then
          echo "has_changes=false" >> $GITHUB_OUTPUT
          echo "No documentation updates needed" >> $GITHUB_STEP_SUMMARY
        else
          echo "has_changes=true" >> $GITHUB_OUTPUT
          echo "Documentation updates detected" >> $GITHUB_STEP_SUMMARY

          # Show what changed
          echo "### Changed Files:" >> $GITHUB_STEP_SUMMARY
          echo '```' >> $GITHUB_STEP_SUMMARY
          git diff --cached --name-only >> $GITHUB_STEP_SUMMARY
          echo '```' >> $GITHUB_STEP_SUMMARY

          # Verify only documentation files changed
          CHANGED=$(git diff --cached --name-only)
          INVALID_FILES=""

          for file in $CHANGED; do
            FILE_LOWER=$(echo "$file" | tr '[:upper:]' '[:lower:]')
            if [[ "$FILE_LOWER" != "readme.md" ]] && [[ "$FILE_LOWER" != "claude.md" ]]; then
              INVALID_FILES="$INVALID_FILES $file"
            fi
          done

          if [ -n "$INVALID_FILES" ]; then
            echo "ERROR: Non-documentation files were modified:$INVALID_FILES" >> $GITHUB_STEP_SUMMARY
            echo "Only README.md and CLAUDE.md (any casing) should be updated." >> $GITHUB_STEP_SUMMARY
            git reset --hard
            echo "has_changes=false" >> $GITHUB_OUTPUT
            exit 1
          fi
        fi

    - name: Close Existing DocSync PRs
      if: steps.check-changes.outputs.has_changes == 'true'
      shell: bash
      env:
        GH_TOKEN: ${{ inputs.github_token }}
      run: |
        echo "Checking for existing DocSync AI PRs..."

        # Find and close any existing documentation update PRs
        EXISTING_PRS=$(gh pr list \
          --search "DocSync AI: Update Documentation" \
          --state open \
          --json number \
          --jq '.[].number' 2>/dev/null || echo "")

        if [ -n "$EXISTING_PRS" ]; then
          echo "Found existing PRs to close:"
          for pr in $EXISTING_PRS; do
            echo "  Closing PR #$pr..."
            gh pr close "$pr" \
              --comment "Closing stale documentation PR. A fresh update will be created." \
              --delete-branch 2>/dev/null || echo "  Could not close PR #$pr"
          done
          echo "Closed $(echo "$EXISTING_PRS" | wc -w | tr -d ' ') existing PR(s)" >> $GITHUB_STEP_SUMMARY
        else
          echo "No existing DocSync AI PRs found"
        fi

    - name: Create Documentation PR
      id: create-doc-pr
      if: steps.check-changes.outputs.has_changes == 'true'
      shell: bash
      env:
        GH_TOKEN: ${{ inputs.github_token }}
        BASE_BRANCH: ${{ inputs.base_branch }}
        PR_LABELS: ${{ inputs.pr_labels }}
        TEMP_DIR: ${{ steps.pr-details.outputs.temp_dir }}
      run: |
        set -e

        # Use local git config only
        git config --local user.name "github-actions[bot]"
        git config --local user.email "github-actions[bot]@users.noreply.github.com"

        # Verify configuration was set
        CONFIGURED_NAME=$(git config --local user.name)
        if [ "$CONFIGURED_NAME" != "github-actions[bot]" ]; then
          echo "Failed to set git user configuration" >> $GITHUB_STEP_SUMMARY
          exit 1
        fi

        # Generate secure branch name
        TIMESTAMP=$(date +%Y%m%d-%H%M%S)
        RANDOM_SUFFIX=$(openssl rand -hex 4)
        BRANCH="docs/auto-update-${TIMESTAMP}-${RANDOM_SUFFIX}"

        # Validate branch name
        if ! [[ "$BRANCH" =~ ^[a-zA-Z0-9/_-]+$ ]]; then
          echo "Generated invalid branch name" >> $GITHUB_STEP_SUMMARY
          exit 1
        fi

        # Check branch doesn't already exist
        if git rev-parse --verify "$BRANCH" 2>/dev/null; then
          echo "Branch $BRANCH already exists, using alternative" >> $GITHUB_STEP_SUMMARY
          BRANCH="${BRANCH}-$(openssl rand -hex 4)"
        fi

        git checkout -b "$BRANCH"

        # Add only documentation files (case-insensitive match, type f only)
        find . -maxdepth 1 -type f \( -iname "readme.md" -o -iname "claude.md" \) -print0 | xargs -0 git add 2>/dev/null || true

        # Create commit with safe message (using heredoc to avoid injection)
        git commit -m "$(cat <<'EOF'
        DocSync AI: Update documentation

        Automatically updated documentation based on weekly merged PR changes.

        Generated by DocSync AI
        EOF
        )"

        git push origin "$BRANCH"

        # Build source PRs list for PR body
        SOURCE_PRS_LIST=""
        if [ -f "$TEMP_DIR/pr_numbers.txt" ]; then
          while IFS= read -r PR_NUM; do
            if [[ "$PR_NUM" =~ ^[0-9]+$ ]]; then
              SOURCE_PRS_LIST="${SOURCE_PRS_LIST}
        - **PR**: #${PR_NUM}"
            fi
          done < "$TEMP_DIR/pr_numbers.txt"
        fi

        # Create PR body safely
        PR_BODY="## Automated Documentation Update (Weekly)

        This PR updates the documentation based on all changes merged in the past week.

        ### Source PRs
        ${SOURCE_PRS_LIST}

        ### Changes
        Documentation has been automatically updated to reflect the latest changes in the codebase.

        ### Review Checklist
        - [ ] Documentation accurately reflects the code changes
        - [ ] No unrelated sections were modified
        - [ ] Formatting and style are consistent
        - [ ] Examples and code snippets are up to date

        ---
        *Automated by DocSync AI (Weekly Sync)*"

        PR_URL=$(gh pr create \
          --title "DocSync AI: Update Documentation" \
          --body "$PR_BODY" \
          --base "$BASE_BRANCH" \
          --head "$BRANCH")

        # Add labels (validate label format)
        PR_NUMBER=$(echo "$PR_URL" | grep -oE '[0-9]+$')
        if [[ "$PR_NUMBER" =~ ^[0-9]+$ ]]; then
          IFS=',' read -ra LABEL_ARRAY <<< "$PR_LABELS"
          for label in "${LABEL_ARRAY[@]}"; do
            # Trim whitespace and validate
            label=$(echo "$label" | xargs)
            if [[ "$label" =~ ^[a-zA-Z0-9_-]+$ ]]; then
              gh pr edit "$PR_NUMBER" --add-label "$label" 2>/dev/null || echo "Label '$label' not found, skipping"
            fi
          done
        fi

        echo "pr_created=true" >> $GITHUB_OUTPUT
        echo "pr_number=$PR_NUMBER" >> $GITHUB_OUTPUT
        echo "pr_url=$PR_URL" >> $GITHUB_OUTPUT

        echo "" >> $GITHUB_STEP_SUMMARY
        echo "### Documentation PR Created: #$PR_NUMBER" >> $GITHUB_STEP_SUMMARY
        echo "$PR_URL" >> $GITHUB_STEP_SUMMARY

        # Clean up temporary directory now that pr_numbers.txt has been read
        rm -rf "$TEMP_DIR" 2>/dev/null || true

    - name: Post Command Reference on DocSync PR
      if: steps.create-doc-pr.outputs.pr_created == 'true'
      shell: bash
      env:
        GH_TOKEN: ${{ inputs.github_token }}
        PR_NUMBER: ${{ steps.create-doc-pr.outputs.pr_number }}
      run: |
        # Build the welcome comment with individually copyable commands
        {
          echo "## ðŸ¤– DocSync AI â€” Command Reference"
          echo ""
          echo "Interact with this PR using the commands below. Each command is individually copyable."
          echo ""
          echo "---"
          echo ""
          echo "**Undo the last documentation update**"
          echo '```'
          echo "@docbot revert last change"
          echo '```'
          echo ""
          echo "**Restore docs to a specific commit**"
          echo '```'
          echo "@docbot revert to <commit-hash>"
          echo '```'
          echo ""
          echo "**Update only README.md**"
          echo '```'
          echo "@docbot update only readme.md <your instruction here>"
          echo '```'
          echo ""
          echo "**Update only CLAUDE.md**"
          echo '```'
          echo "@docbot update only claude.md <your instruction here>"
          echo '```'
          echo ""
          echo "**Update all docs with a free-form instruction**"
          echo '```'
          echo "@docbot <your instruction here>"
          echo '```'
          echo ""
          echo "---"
          echo ""
          echo "### ðŸ’¡ Examples"
          echo ""
          echo "Add usage examples for the auth API:"
          echo '```'
          echo "@docbot add usage examples for the auth API"
          echo '```'
          echo ""
          echo "Fix installation steps in README only:"
          echo '```'
          echo "@docbot update only readme.md fix the installation steps"
          echo '```'
          echo ""
          echo "Add architecture notes in CLAUDE.md only:"
          echo '```'
          echo "@docbot update only claude.md add architecture details for the new module"
          echo '```'
          echo ""
          echo "---"
          echo "_A ðŸ‘ reaction on your comment means DocSync AI is processing your request._"
        } > /tmp/docbot_welcome.md

        gh pr comment "$PR_NUMBER" --body-file /tmp/docbot_welcome.md
        rm -f /tmp/docbot_welcome.md

        echo "ðŸ“‹ Posted command reference on PR #$PR_NUMBER" >> $GITHUB_STEP_SUMMARY

    - name: No Updates Needed
      if: steps.pr-details.outputs.skip_analysis == 'true' || steps.claude-analysis.outputs.skip_analysis == 'true' || steps.check-changes.outputs.has_changes == 'false'
      shell: bash
      env:
        TEMP_DIR: ${{ steps.pr-details.outputs.temp_dir }}
      run: |
        echo "pr_created=false" >> $GITHUB_OUTPUT
        echo "Documentation is up to date - no changes needed" >> $GITHUB_STEP_SUMMARY
        rm -rf "$TEMP_DIR" 2>/dev/null || true